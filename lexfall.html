<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Lexfall</title>
  <style>
  /* Legacy-friendly styles: no CSS variables, flex fallback by default */
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; margin:0; padding:12px; background:#f0f0f0; }
  h1 { margin:6px 0 4px; font-size:1.25rem; }

  #container { position:relative; width:100%; max-width:420px; margin:0 auto; }

  /* Fixed settings icon */
  #settingsIcon {
    position:fixed; top:8px; right:8px; width:36px; height:36px;
    display:inline-flex; align-items:center; justify-content:center;
    background:#ffffff; border:2px solid #cccccc; border-radius:50%;
    text-decoration:none; z-index:9999; box-shadow:0 1px 2px rgba(0,0,0,0.08);
  }
  #settingsIcon svg { width:18px; height:18px; fill:#333333; }

  /* HUD */
  #hud { max-width:420px; margin:8px auto 10px; }
  #wordDisplay { font-weight:700; margin-bottom:4px; }
  #scoreDisplay, #turnsLeft { display:inline-block; width:49%; font-size:0.95rem; }

  /* Game: flex fallback (default) */
  #game {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    width:100%;
    position:relative;
    background:#e0e0e0;
    border-radius:12px;
    padding:6px;
    min-height:320px; /* ensures visibility if JS sizing fails */
  }

  .tile {
    background:#ffffff;
    border:2px solid #cccccc;
    font-size:2.1em;
    font-weight:800;
    user-select:none;
    border-radius:12px;
    transition:background .15s;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    touch-action:none;
    width:calc(25% - 8px);
    margin:4px;
    /* height will be set equal to width via JS to make squares */
    overflow:hidden;
  }
  .tile.selected { background:#e8f0ff; border-color:#cccccc; }
  .tile.selected.valid { background:#bff0cf; border-color:#3bb273; }
  .tile.selected.invalid { background:#ffecec; border-color:#dc3545; }
  .tile.empty { background:#f9f9f9; border:2px dashed #dddddd; }
  .tile .score { position:absolute; right:6px; bottom:4px; font-size:.5em; opacity:.8; }

  #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }

  #controls { display:flex; justify-content:center; gap:10px; margin:10px auto; }
  button { padding:.9em 1.1em; margin:.2em; font-size:1em; border-radius:10px; border:none; cursor:pointer; }
  #confirm { background:#3bb273; color:#fff; display:none; }
  #reject { background:#dc3545; color:#fff; display:none; }

  /* New Game emphasis */
  #newGame {
    display:none; background:#ff8c00; color:#fff; font-weight:800;
    box-shadow:0 0 0 0 rgba(255,140,0,0.7);
    animation:pulseGlow 1.7s infinite;
  }
  @keyframes pulseGlow {
    0% { box-shadow:0 0 0 0 rgba(255,140,0,0.7); }
    70% { box-shadow:0 0 0 16px rgba(255,140,0,0); }
    100% { box-shadow:0 0 0 0 rgba(255,140,0,0); }
  }

  #status { max-width:420px; margin:8px auto 0; font-size:.98em; }

  /* If CSS Grid is supported, use it */
  @supports (display: grid) {
    #game {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:6px;
      padding:6px;
    }
    .tile { width:auto; margin:0; }
  }

  /* Responsive tweaks */
  @media (max-width: 380px) {
    .tile { font-size:1.7em; }
    #settingsIcon { width:32px; height:32px; }
    #settingsIcon svg { width:16px; height:16px; }
  }
  @media (max-width: 330px) {
    .tile { font-size:1.55em; }
  }
</style>
</head>
<body>

<h1>Lexfall</h1>
<a id="settingsIcon" href="settings.html" aria-label="Settings" title="Settings">
  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
    <path d="M12 8.8a3.2 3.2 0 1 0 0 6.4 3.2 3.2 0 0 0 0-6.4zm9.4 3.2c0-.5 0-.9-.1-1.3l2-1.6-2-3.4-2.4 1a8.8 8.8 0 0 0-2.2-1.3l-.3-2.6H9.6l-.3 2.6a8.8 8.8 0 0 0-2.2 1.3l-2.4-1-2 3.4 2 1.6c0 .4-.1 .8-.1 1.3s0 .9 .1 1.3l-2 1.6 2 3.4 2.4-1c.7 .5 1.4 .9 2.2 1.3l.3 2.6h4.6l.3-2.6c.8-.4 1.5-.8 2.2-1.3l2.4 1 2-3.4-2-1.6c.1-.4 .1-.8 .1-1.3zM12 6.6a5.4 5.4 0 1 1 0 10.8A5.4 5.4 0 0 1 12 6.6z"/>
  </svg>
</a>
<div id="hud">
  <div id="wordDisplay">Word:</div>
  <div id="scoreDisplay">Score: 0</div>
  <div id="turnsLeft">Turns Left: 10</div>
</div>
<div id="container">
  <div id="game"></div>
  <svg id="overlay"></svg>
</div>
<div id="controls">
  <button id="confirm" type="button" onclick="confirmWord(true)">Confirm</button>
  <button id="reject">Clear</button>
  <button id="newGame">New Game</button>
</div>
<div id="status"></div>

<script>
// --- Minimal polyfills for weak browsers ---
if (!('Math' in window && typeof Math.hypot === 'function')) {
  Math.hypot = function(){ var s=0; for (var i=0;i<arguments.length;i++){ var n=Number(arguments[i])||0; s+=n*n; } return Math.sqrt(s); };
}
if (typeof window.Set === 'undefined') {
  (function(){
    function SimpleSet(){ this._o = Object.create(null); }
    SimpleSet.prototype.add = function(v){ this._o[v] = 1; return this; };
    SimpleSet.prototype.has = function(v){ return !!this._o[v]; };
    window.Set = SimpleSet;
  })();
}

// ---- Config ----
var ROWS = 4, COLS = 4;
var TILE_RADIUS_PX = 35;
var MAX_WORD_LEN = 16;
var DEFAULT_TURNS = 10;
var LETTER_SCORES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10};

// ---- DOM ----
var gameEl = document.getElementById('game');
var overlay = document.getElementById('overlay');
var wordDisplay = document.getElementById('wordDisplay');
var scoreDisplay = document.getElementById('scoreDisplay');
var turnsDisplay = document.getElementById('turnsLeft');
var statusEl = document.getElementById('status');
var btnConfirm = document.getElementById('confirm');
var btnReject = document.getElementById('reject');
var btnNewGame = document.getElementById('newGame');

// Pointer/touch/mouse support
var HAS_POINTER = !!window.PointerEvent;

// ---- Game State ----
var grid = [], selectedTiles = [], score = 0, turns = DEFAULT_TURNS;
var pointerActive = false, paused = false, slidThisGesture = false;
var DICT = new Set();
var PREFIX = new Set();
var dictionaryReady = false;
var settings = { minLen: 3, autoConfirm: true };

// ---- Utils ----
function showStatus(html, type){ statusEl.innerHTML = '<div class="' + (type||'info') + '">' + html + '</div>'; }
function clearStatus(){ statusEl.innerHTML = ''; }

function saveState() {
  try {
    var letters = grid.map(function(row){ return row.map(function(cell){ return cell.letter; }); });
    var state = { letters: letters, score: score, turns: turns };
    localStorage.setItem('lexfall_state', JSON.stringify(state));
  } catch (e) {}
}

function loadState() {
  try {
    var raw = localStorage.getItem('lexfall_state');
    if (!raw) return false;
    var s = JSON.parse(raw);
    if (!s || !Array.isArray(s.letters) || typeof s.score !== 'number' || typeof s.turns !== 'number') return false;
    grid = [];
    for (var r=0; r<ROWS; r++){
      var row = [];
      for (var c=0; c<COLS; c++){
        var letter = (s.letters[r] && s.letters[r][c]) || null;
        // Sanitize: require A-Z single char, else random
        if (typeof letter !== 'string' || !/^[A-Z]$/.test(letter)) letter = randomLetter();
        row.push({ letter: letter, element: null });
      }
      grid.push(row);
    }
    score = s.score; turns = s.turns;
    return true;
  } catch (e) { return false; }
}

function loadSettings(){
  try {
    var s = JSON.parse(localStorage.getItem('lexfall_settings')||'{}');
    if (s && typeof s.minLen==='number') settings.minLen = Math.max(2, Math.min(16, s.minLen));
    if (typeof s.autoConfirm==='boolean') settings.autoConfirm = s.autoConfirm;
  } catch(e){}
}

// Maintain square grid for browsers without aspect-ratio
function sizeGridSquare(){
  try {
    var supportsAspect = (window.CSS && CSS.supports && CSS.supports('aspect-ratio', '1/1'));
    if (!supportsAspect) {
      var w = gameEl.clientWidth || 320;
      gameEl.style.height = w + 'px';
    }
  } catch(e){}
  // Also size overlay to match
  var rect = gameEl.getBoundingClientRect();
  overlay.setAttribute('width', rect.width);
  overlay.setAttribute('height', rect.height);
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
}
window.addEventListener('resize', sizeGridSquare);

// Make tiles square for legacy browsers (no CSS aspect-ratio or grid)
function sizeTilesSquare(){
  try {
    var tiles = gameEl.getElementsByClassName('tile');
    if (!tiles || !tiles.length) return;
    for (var i=0;i<tiles.length;i++){
      var w = tiles[i].offsetWidth || 0;
      if (w > 0) { tiles[i].style.height = w + 'px'; }
    }
    // Sync overlay box to #game
    var rect = gameEl.getBoundingClientRect();
    overlay.setAttribute('width', rect.width);
    overlay.setAttribute('height', rect.height);
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
  } catch(e){}
}
window.addEventListener('resize', sizeTilesSquare);


// Letter randomizer
function randomLetter() {
  var letters = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";
  return letters[Math.floor(Math.random() * letters.length)];
}

// Build empty grid and tiles
function makeRandomGrid() {
  grid = [];
  for (var r = 0; r < ROWS; r++) {
    var row = [];
    for (var c = 0; c < COLS; c++) row.push({ letter: randomLetter(), element: null });
    grid.push(row);
  }
}

function renderGrid() {
  gameEl.innerHTML = '';
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  setTimeout(sizeGridSquare, 0);
  setTimeout(sizeTilesSquare, 0);
  updateWordDisplay();
  drawPath();
}

function isInBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
function alreadySelected(r, c) { for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; if (t[0]===r && t[1]===c) return true; } return false; }
function isAdjacentForgiving(r, c, pr, pc) { return Math.abs(r - pr) <= 1 && Math.abs(c - pc) <= 1; }

function selectTile(r, c) {
  if (!isInBounds(r, c) || paused) return;
  if (alreadySelected(r, c)) return;
  if (!grid[r][c].letter) return;
  if (selectedTiles.length > 0) {
    var last = selectedTiles[selectedTiles.length - 1];
    if (!isAdjacentForgiving(r, c, last[0], last[1])) return;
  }
  selectedTiles.push([r, c]);
  if (selectedTiles.length >= 2) { slidThisGesture = true; }
  grid[r][c].element.className += ' selected';
  updateWordDisplay();
  drawPath();
}

function currentWord() {
  var out = '';
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; out += grid[t[0]][t[1]].letter; }
  return out;
}

function refreshSelectionStyles() {
  var up = currentWord().toUpperCase();
  var meetsLen = up.length >= settings.minLen;
  var isValid = up.length > 0 && meetsLen && (dictionaryReady ? DICT.has(up) : true);
  var isDead = dictionaryReady && up.length > 0 && !PREFIX.has(up);
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bvalid\b|\binvalid\b/g, '').trim();
    if (isValid) el.className += ' valid';
    else if (isDead) el.className += ' invalid';
  }
  btnConfirm.style.display = (dictionaryReady ? (isValid ? 'inline-block' : 'none') : (meetsLen ? 'inline-block' : 'none'));
  btnConfirm.disabled = false;
  btnReject.style.display = selectedTiles.length ? 'inline-block' : 'none';
}

function updateWordDisplay() {
  var word = currentWord();
  refreshSelectionStyles();
  if (!word.length) wordDisplay.textContent = 'Word:';
  else {
    var pts = calculateScore(word.toUpperCase());
    wordDisplay.textContent = 'Word: ' + word + ' (' + pts + ')';
  }
}

function calculateScore(word) {
  var acc = 0;
  for (var i=0;i<word.length;i++){ var ch = word.charAt(i); acc += LETTER_SCORES[ch] || 0; }
  return acc;
}

function confirmWord(force) {
  if (selectedTiles.length === 0 || turns === 0) return;
  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= settings.minLen;
  if (!force && !((dictionaryReady ? DICT.has(word) : true) && meetsLen)) { rejectWord(); return; }
  var wordScore = calculateScore(word);
  score += wordScore; scoreDisplay.textContent = 'Score: ' + score;
  turns--; turnsDisplay.textContent = 'Turns Left: ' + turns;
  removeAndDropTiles();
  clearSelection();
  saveState();
  maybeFinishGame();
}

function showWellDone() {
  for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) grid[r][c].letter = '';
  var row1 = ['W','E','L','L'];
  var row2 = ['D','O','N','E'];
  for (var c = 0; c < COLS; c++) { grid[1][c].letter = row1[c]; }
  for (var c = 0; c < COLS; c++) { grid[2][c].letter = row2[c]; }
  renderGrid();
}

function maybeFinishGame() {
  if (turns <= 0) {
    paused = true;
    showStatus('<strong>Congratulations!</strong> Final score: <strong>' + score + '</strong>.', 'success');
    showWellDone();
    btnNewGame.style.display = 'inline-block';
  }
}

function rejectWord() { clearSelection(); }

function clearSelection() {
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bselected\b|\bvalid\b|\binvalid\b/g,'').trim();
  }
  selectedTiles = [];
  updateWordDisplay();
  drawPath();
}

// Remove selected tiles, drop down, refill from top
function removeAndDropTiles() {
  // Remove
  for (var i=0;i<selectedTiles.length;i++){ var rc = selectedTiles[i]; grid[rc[0]][rc[1]].letter = null; }
  // Drop down per column
  for (var c = 0; c < COLS; c++) {
    var letters = [];
    for (var r = ROWS - 1; r >= 0; r--) if (grid[r][c].letter) letters.push(grid[r][c].letter);
    for (var r = ROWS - 1; r >= 0; r--) grid[r][c].letter = letters[ROWS - 1 - r] || null;
    for (var r = 0; r < ROWS; r++) if (!grid[r][c].letter) grid[r][c].letter = randomLetter();
  }
  renderGrid();
  ensurePlayableOrReshuffle();
}

// --- Hit testing helpers ---
function getTileCenter(r, c) {
  var gridRect = gameEl.getBoundingClientRect();
  var tile = grid[r][c].element; var tileRect = tile.getBoundingClientRect();
  return { x: tileRect.left + tileRect.width / 2 - gridRect.left, y: tileRect.top + tileRect.height / 2 - gridRect.top };
}

function tileFromPointerEvent(e) {
  var gridRect = gameEl.getBoundingClientRect();
  var clientX = (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
  var clientY = (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);
  var x = clientX - gridRect.left;
  var y = clientY - gridRect.top;
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      if (!grid[r][c].letter) continue;
      var center = getTileCenter(r, c); var dx = x - center.x; var dy = y - center.y;
      if (Math.hypot(dx, dy) < TILE_RADIUS_PX) return [r, c];
    }
  }
  return null;
}

// --- Pointer interactions ---
function pointerDown(e) {
  if (paused) return;
  if (e && e.preventDefault) e.preventDefault();
  pointerActive = true; slidThisGesture = false;
  var tile = tileFromPointerEvent(e);
  if (tile) selectTile(tile[0], tile[1]);
}

function pointerMove(e) {
  if (!pointerActive || paused) return;
  if (e && e.preventDefault) e.preventDefault();
  var tile = tileFromPointerEvent(e); if (!tile) return;
  var r = tile[0], c = tile[1];
  if (!alreadySelected(r, c)) {
    if (selectedTiles.length === 0) selectTile(r, c);
    else {
      var last = selectedTiles[selectedTiles.length - 1];
      if (isAdjacentForgiving(r, c, last[0], last[1])) { selectTile(r, c); slidThisGesture = true; }
    }
  }
}

function onGestureEnd(){
  if (!pointerActive) return; 
  pointerActive = false;
  var wasSlide = !!slidThisGesture;
  slidThisGesture = false;
  if (!wasSlide) return; // taps: do nothing (no auto-confirm or auto-cancel)

  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= settings.minLen;
  if (!settings.autoConfirm) return;

  var ok = dictionaryReady ? DICT.has(word) : true;
  if (meetsLen && ok) { 
    confirmWord(true);
  } else if (dictionaryReady) { 
    // Only auto-cancel when we know it's invalid via dictionary, and only for slides
    rejectWord();
  }
}

// Attach listeners
// Simple closest polyfill
function closestEl(el, selector){
  while (el && el.nodeType === 1){
    if ((el.matches && el.matches(selector)) || (el.msMatchesSelector && el.msMatchesSelector(selector))) return el;
    el = el.parentNode;
  }
  return null;
}
// Click-to-select fallback (helps Safari/old browsers where pointer events can be finicky)
gameEl.addEventListener('click', function(e){
  var t = closestEl(e.target, '.tile');
  if (!t) return;
  var r = parseInt(t.getAttribute('data-row'), 10);
  var c = parseInt(t.getAttribute('data-col'), 10);
  if (!isNaN(r) && !isNaN(c)) { selectTile(r, c); }
}, { passive: true });

function attachInputListeners(){
  if (HAS_POINTER) {
    gameEl.addEventListener('pointerdown', function(e){ pointerDown(e); try { if (gameEl.setPointerCapture) gameEl.setPointerCapture(e.pointerId); } catch(_e){} }, { passive: false });
    gameEl.addEventListener('pointermove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('pointerup', onGestureEnd, { passive: true });
  } else {
    gameEl.addEventListener('touchstart', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('touchmove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('touchend', onGestureEnd, { passive: true });
    gameEl.addEventListener('mousedown', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('mousemove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('mouseup', onGestureEnd, { passive: true });
  }
}

// --- Path drawing with SVG lines ---
function drawPath() {
  overlay.innerHTML = '';
  if (selectedTiles.length < 2) return;
  var points = [];
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; points.push(getTileCenter(t[0], t[1])); }
  var path = '';
  for (var i = 0; i < points.length - 1; i++) {
    path += '<line x1="' + points[i].x + '" y1="' + points[i].y + '" x2="' + points[i+1].x + '" y2="' + points[i+1].y + '" stroke="#007bff" stroke-width="5" stroke-linecap="round"/>';
  }
  overlay.innerHTML = path;
}

// --- Dictionary loading ---
async function loadDictionary() {
  try {
    var res = await fetch('en-words.txt');
    if (!res.ok) throw new Error('fetch failed');
    var text = await res.text();
    text.split(/\r?\n/).forEach(function(w){
      w = (w||'').trim(); if (!w) return; var up = w.toUpperCase(); if (up.length > MAX_WORD_LEN) return;
      DICT.add(up);
      for (var i = 1; i <= up.length; i++) PREFIX.add(up.slice(0, i));
    });
    dictionaryReady = true;
  } catch(e) { dictionaryReady = false; }
}

// --- Playability check ---
function gridHasAnyWord() {
  var visited = Array(ROWS); for (var r=0;r<ROWS;r++){ visited[r]=Array(COLS); for (var c=0;c<COLS;c++) visited[r][c]=false; }
  var dirs = [-1, 0, 1];
  function dfs(r, c, prefix) {
    var next = prefix + grid[r][c].letter;
    var up = next.toUpperCase();
    if (dictionaryReady && !PREFIX.has(up)) return false;
    if (dictionaryReady && DICT.has(up)) return true;
    visited[r][c] = true;
    for (var i=0;i<dirs.length;i++) for (var j=0;j<dirs.length;j++){
      var dr = dirs[i], dc = dirs[j];
      if (dr === 0 && dc === 0) continue;
      var nr = r + dr, nc = c + dc;
      if (isInBounds(nr, nc) && !visited[nr][nc]) {
        if (dfs(nr, nc, next)) { visited[r][c] = false; return true; }
      }
    }
    visited[r][c] = false; return false;
  }
  for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) if (dfs(r, c, '')) return true;
  return !dictionaryReady; // if no dictionary, assume playable
}

function ensurePlayableOrReshuffle() {
  if (gridHasAnyWord()) { clearStatus(); saveState(); return; }
  paused = true; btnConfirm.disabled = true; btnReject.disabled = true;
  showStatus('<strong>No words found</strong>, reshuffling...', 'warn');
  var attempts = 0;
  var tryReshuffle = function () {
    attempts++;
    makeRandomGrid(); renderGrid();
    if (gridHasAnyWord() || attempts > 50) {
      paused = false; btnConfirm.disabled = false; btnReject.disabled = false; clearStatus(); saveState();
    } else {
      setTimeout(tryReshuffle, 0);
    }
  };
  tryReshuffle();
}

// ---- Controls ----
btnConfirm.addEventListener('click', function(){ confirmWord(true); });
btnReject.addEventListener('click', rejectWord);
btnNewGame.addEventListener('click', function(){
  score = 0; turns = DEFAULT_TURNS; scoreDisplay.textContent = 'Score: ' + score; turnsDisplay.textContent = 'Turns Left: ' + turns;
  makeRandomGrid(); renderGrid(); clearSelection(); paused = false; btnNewGame.style.display = 'none'; clearStatus(); ensurePlayableOrReshuffle(); saveState();
});

// ---- Boot ----
(function init(){
  loadSettings();
  // Load dict but do not block the UI; tiles should render even if it fails
  try { loadDictionary(); } catch(e) {}
  var restored = loadState();
  if (!restored) makeRandomGrid();
  renderGrid();
  scoreDisplay.textContent = 'Score: ' + score;
  turnsDisplay.textContent = 'Turns Left: ' + turns;
  attachInputListeners();
  sizeGridSquare();
  sizeTilesSquare();
  ensurePlayableOrReshuffle();
})();
</script>
</body>
</html>
