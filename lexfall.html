<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lexfall â€” Stable Build</title>
<style>
  :root { --green:#3bb273; --green-soft:#bff0cf; --red:#dc3545; --blue:#336; --bg:#f7f7f8; --tile-bg:#fff; --tile-border:#cfcfd4; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin:0; padding:16px; text-align:center; background:var(--bg); color:#111; }
  h1 { margin:6px 0 10px; font-size: 1.35rem; }
  #container { width:100%; max-width: 440px; margin: 0 auto; }
  #current { font-weight:700; margin:6px auto 10px; }

  #game { display:grid; grid-template-columns:repeat(4,1fr); gap:8px; width:100%; touch-action:none; }
  .tile { background:var(--tile-bg); border:2px solid var(--tile-border); border-radius:14px; position:relative; display:flex; align-items:center; justify-content:center; aspect-ratio:1/1; user-select:none; transition: transform .08s ease, box-shadow .12s ease; }
  .tile:hover { transform: translateY(-2px); }
  .tile .letter { font-size:2.1rem; font-weight:800; letter-spacing:.02em; }
  .tile .score { position:absolute; right:6px; bottom:4px; font-size:.72rem; opacity:.8; }
  .tile.selected { box-shadow: 0 0 0 2px rgba(51,102,153,.18) inset; }
  .tile.selected.valid { background: var(--green-soft); border-color: var(--green); box-shadow:0 0 0 2px rgba(59,178,115,.35) inset; }
  .tile.selected.invalid { background:#ffefef; border-color: var(--red); box-shadow:0 0 0 2px rgba(220,53,69,.25) inset; }

  #controls { margin:12px auto 0; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
  button { padding:10px 14px; border-radius:10px; border:none; font-weight:600; cursor:pointer; }
  #confirm { background:var(--green); color:#fff; display:none; }
  #reject { background:#e9e9ef; color:#111; display:none; }
  #settingsBtn { background:#1f6feb; color:#fff; }
  button[disabled]{ opacity:.5; cursor:not-allowed; }

  #status { max-width:440px; margin:10px auto 0; text-align:left; }
  #status .card { background:#fff; border:1px solid #e4e4ea; border-radius:12px; padding:10px 12px; }

  /* Settings modal */
  #settingsModal { display:none; position:fixed; inset:0; background:rgba(0,0,0,.4); align-items:center; justify-content:center; }
  #settingsModal .panel { background:#fff; padding:16px; border-radius:12px; width:min(440px, 92vw); text-align:left; }
  #settingsModal label { display:block; margin:8px 0 4px; font-weight:600; }
  #settingsModal .row { display:flex; gap:8px; align-items:center; }
  #settingsModal input[type="number"] { width:80px; }
  #settingsModal .actions { display:flex; gap:8px; justify-content:flex-end; margin-top:12px; }

  /* Fallback for very old browsers without CSS Grid */
  .no-grid { display:flex !important; flex-wrap:wrap; gap:8px; }
  .no-grid .tile { width: calc(25% - 8px); }
</style>
</head>
<body>
  <div id="container">
    <h1>Lexfall</h1>
    <div id="current">Word: <span id="currentWord"></span> <span id="currentPts" style="opacity:.75"></span></div>
    <div id="game"></div>
    <div id="controls">
      <button id="confirm">Confirm</button>
      <button id="reject">Clear</button>
      <button id="settingsBtn">Settings</button>
    </div>
    <div id="status"><div class="card">Slide or click to select adjacent letters.</div></div>
  </div>

  <div id="settingsModal">
    <div class="panel">
      <h3>Settings</h3>
      <label for="minLen">Minimum word length</label>
      <div class="row">
        <input id="minLen" type="number" min="2" max="16" step="1"/>
        <span>(Dictionary min is 2)</span>
      </div>
      <label class="row"><input id="autoConfirm" type="checkbox"/> Auto-confirm on slide release</label>
      <div class="actions">
        <button id="saveSettings">Save</button>
        <button id="closeSettings">Close</button>
      </div>
    </div>
  </div>

<script>
// --- Config ---
const ROWS = 4, COLS = 4, MAX_WORD_LEN = 16;
const LETTER_SCORES = { A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10 };
function calculateScore(word){ return [...word].reduce((s,ch)=>s+(LETTER_SCORES[ch]||0),0); }

// --- State & DOM ---
let grid = [], selectedTiles = [], pointerActive = false, slidThisGesture = false;
const gameEl = document.getElementById('game');
const statusEl = document.getElementById('status');
const btnConfirm = document.getElementById('confirm');
const btnReject  = document.getElementById('reject');
const btnSettings = document.getElementById('settingsBtn');
const currentWordEl = document.getElementById('currentWord');
const currentPtsEl = document.getElementById('currentPts');
const modal = document.getElementById('settingsModal');
const inputMinLen = document.getElementById('minLen');
const inputAuto = document.getElementById('autoConfirm');
const btnSaveSettings = document.getElementById('saveSettings');
const btnCloseSettings = document.getElementById('closeSettings');
let DICT = new Set(); let PREFIX = new Set();
let settings = { minLen: 3, autoConfirm: true };

function loadSettings(){ try { const s = JSON.parse(localStorage.getItem('lexfall_settings')||'{}'); if (typeof s.minLen==='number') settings.minLen=Math.max(2,Math.min(16,s.minLen)); if (typeof s.autoConfirm==='boolean') settings.autoConfirm=s.autoConfirm; } catch(e){} }
function persistSettings(){ try { localStorage.setItem('lexfall_settings', JSON.stringify(settings)); } catch(e){} }

// Persist/restore board
function saveState(){ try { const letters = grid.map(row=>row.map(c=>c.letter)); localStorage.setItem('lexfall_state', JSON.stringify({letters})); } catch(e){} }
function loadState(){ try { const raw=localStorage.getItem('lexfall_state'); if(!raw) return false; const s=JSON.parse(raw); if(!s||!Array.isArray(s.letters)) return false; grid = s.letters.map(row=>row.map(letter=>({letter, element:null}))); return true; } catch(e){ return false; } }

// --- Helpers ---
function randomLetter(){ const letters = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ"; return letters[Math.floor(Math.random()*letters.length)]; }
function isAdj(r,c,pr,pc){ return Math.abs(r-pr)<=1 && Math.abs(c-pc)<=1; }
function currentWord(){ return selectedTiles.map(([r,c])=>grid[r][c].letter).join(''); }

// --- Build & Render ---
function makeGrid(){ grid=[]; for(let r=0;r<ROWS;r++){ const row=[]; for(let c=0;c<COLS;c++) row.push({letter:randomLetter(), element:null}); grid.push(row);} }
function renderGrid(){
  gameEl.innerHTML = '';
  for (let r=0;r<ROWS;r++){
    for (let c=0;c<COLS;c++){
      const tile = document.createElement('div');
      tile.className='tile'; tile.dataset.row=r; tile.dataset.col=c;
      const ch = grid[r][c].letter; const val = LETTER_SCORES[ch]||0;
      tile.innerHTML = `<span class="letter">${ch}</span><span class="score">${val}</span>`;
      tile.addEventListener('pointerdown', pointerDown, {passive:false});
      tile.addEventListener('pointermove', pointerMove, {passive:false});
      tile.addEventListener('click', ()=> selectTile(r,c));
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  updateUI();
  saveState();
}

// --- Selection ---
function selectTile(r,c){
  if (selectedTiles.some(([rr,cc])=> rr===r && cc===c)) return;
  if (selectedTiles.length>0){ const [pr,pc]=selectedTiles[selectedTiles.length-1]; if(!isAdj(r,c,pr,pc)) return; }
  selectedTiles.push([r,c]);
  updateUI();
}
function tileFromEvent(e){
  const el = document.elementFromPoint(e.clientX, e.clientY);
  const tile = el && (el.classList?.contains('tile') ? el : el.closest?.('.tile'));
  if (!tile) return null; return [Number(tile.dataset.row), Number(tile.dataset.col)];
}
function pointerDown(e){ e.preventDefault(); pointerActive=true; slidThisGesture=false; const t = tileFromEvent(e); if (t) selectTile(t[0],t[1]); }
function pointerMove(e){ if(!pointerActive) return; e.preventDefault(); const t = tileFromEvent(e); if(!t) return; const [r,c]=t; if(!selectedTiles.some(([rr,cc])=>rr===r&&cc===c)){ if(selectedTiles.length===0) selectTile(r,c); else { const [pr,pc]=selectedTiles[selectedTiles.length-1]; if(isAdj(r,c,pr,pc)){ slidThisGesture=true; selectTile(r,c); } } } }

document.addEventListener('pointerup', ()=>{ if(!pointerActive) return; pointerActive=false; if(selectedTiles.length===0) return; if(!slidThisGesture) return; const w=currentWord().toUpperCase(); const valid = DICT.has(w) && w.length>=settings.minLen; if(settings.autoConfirm && valid) confirmWord(); else if (settings.autoConfirm) clearSelection(); });

// --- UI update ---
function updateUI(){
  document.querySelectorAll('.tile').forEach(t=>t.classList.remove('selected','valid','invalid'));
  const w = currentWord(); const up = w.toUpperCase(); const hasSel = selectedTiles.length>0; const isValid = hasSel && DICT.has(up) && up.length>=settings.minLen;
  selectedTiles.forEach(([r,c])=> grid[r][c].element.classList.add('selected', isValid? 'valid':'invalid'));
  currentWordEl.textContent = w; currentPtsEl.textContent = w? `(${calculateScore(up)})`:'';
  btnConfirm.style.display = isValid ? 'inline-block' : 'none';
  btnReject.style.display  = hasSel ? 'inline-block' : 'none';
}
function clearSelection(){ selectedTiles=[]; updateUI(); }

// --- Confirm + Remove/Drop ---
function removeAndDropTiles(){
  selectedTiles.forEach(([r,c])=>{ grid[r][c].letter = null; });
  for(let c=0;c<COLS;c++){
    const letters=[]; for(let r=ROWS-1;r>=0;r--) if(grid[r][c].letter) letters.push(grid[r][c].letter);
    for(let r=ROWS-1;r>=0;r--) grid[r][c].letter = letters[ROWS-1-r] || null;
    for(let r=0;r<ROWS;r++) if(!grid[r][c].letter) grid[r][c].letter = randomLetter();
  }
  renderGrid();
}
function confirmWord(){ const w=currentWord().toUpperCase(); if(!(DICT.has(w) && w.length>=settings.minLen)) { clearSelection(); return; } const pts=calculateScore(w); statusEl.innerHTML = `<div class='card'>Confirmed: <strong>${w}</strong> (${pts})</div>`; removeAndDropTiles(); clearSelection(); }
function rejectWord(){ clearSelection(); statusEl.innerHTML = `<div class='card'>Selection cleared.</div>`; }

// --- Dictionary ---
async function loadDictionary(){ const res=await fetch('en-words.txt'); const text=await res.text(); text.split(/\r?\n/).forEach(w=>{ const up=w.trim().toUpperCase(); if(!up||up.length>MAX_WORD_LEN) return; DICT.add(up); for(let i=1;i<=up.length;i++) PREFIX.add(up.slice(0,i)); }); }

// --- Events ---
btnConfirm.addEventListener('click', confirmWord);
btnReject.addEventListener('click', rejectWord);
btnSettings.addEventListener('click', ()=>{ inputMinLen.value = settings.minLen; inputAuto.checked = !!settings.autoConfirm; modal.style.display = 'flex'; });
btnCloseSettings.addEventListener('click', ()=>{ modal.style.display = 'none'; });
btnSaveSettings.addEventListener('click', ()=>{ settings.minLen = Math.max(2, Math.min(16, parseInt(inputMinLen.value||'3',10))); settings.autoConfirm = !!inputAuto.checked; persistSettings(); modal.style.display = 'none'; updateUI(); });

// --- Boot ---
(async function init(){
  loadSettings();
  await loadDictionary();
  const restored = loadState();
  if (!restored) makeGrid();
  // fallback if CSS Grid not supported
  try { if (!(window.CSS && CSS.supports && CSS.supports('display','grid'))) { gameEl.classList.add('no-grid'); } } catch(e){ gameEl.classList.add('no-grid'); }
  renderGrid();
})();
</script>
</body>
</html>
