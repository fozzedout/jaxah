<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lexfall</title>
  <style>
    :root { --green:#3bb273; --green-soft:#bff0cf; --red:#dc3545; --blue:#339; --bg:#f0f0f0; --tile-bg:#fff; --tile-border:#ccc; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; margin:0; padding:12px; background:var(--bg); }
    h1 { margin:6px 0 4px; font-size:1.25rem; }

    #container { position:relative; width:100%; max-width:420px; margin:0 auto; }

    /* Settings icon fixed at top right of the screen */
    #settingsIcon {
      position:fixed; top:8px; right:8px; width:36px; height:36px;
      display:inline-flex; align-items:center; justify-content:center;
      background:#ffffff; border:2px solid var(--tile-border); border-radius:50%;
      text-decoration:none; z-index:9999; box-shadow:0 1px 2px rgba(0,0,0,0.08);
    }
    #settingsIcon svg { width:18px; height:18px; fill:#333333; }

    /* HUD at the top */
    #hud { max-width:420px; margin:8px auto 10px; display:grid; grid-template-columns:1fr 1fr; gap:8px; }
    #wordDisplay { grid-column:1 / -1; font-weight:700; }
    #scoreDisplay, #turnsLeft { font-size:0.95rem; }

    #game { display:grid; grid-template-columns:repeat(4,1fr); gap:6px; width:100%; aspect-ratio:1/1; position:relative; z-index:1; touch-action:none; background:#e0e0e0; border-radius:12px; padding:6px; }
    .tile { background:var(--tile-bg); border:2px solid var(--tile-border); font-size:2.1em; font-weight:800; user-select:none; border-radius:12px; transition:background .15s, transform .05s; min-width:0; min-height:96px; display:flex; align-items:center; justify-content:center; position:relative; z-index:2; touch-action:none; }
    .tile.selected { background:#e8f0ff; border-color:var(--tile-border); }
    .tile.selected.valid { background:var(--green-soft); border-color:var(--green); }
    .tile.selected.invalid { background:#ffecec; border-color:var(--red); }
    .tile.empty { background:transparent; border:none; }
    .tile .score { position:absolute; right:6px; bottom:4px; font-size:.5em; opacity:.8; }

    #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }

    #controls { display:flex; justify-content:center; gap:10px; margin:10px auto; }
    button { padding:.9em 1.1em; margin:.2em; font-size:1em; border-radius:10px; border:none; cursor:pointer; }
    #confirm { background:var(--green); color:#fff; display:none; }
    #reject { background:var(--red); color:#fff; display:none; }

    /* Make New Game button stand out more */
    #newGame {
      display:none; background:#ff8c00; color:#fff; font-weight:800;
      box-shadow:0 0 0 0 rgba(255,140,0,0.7); transform:translateZ(0);
      animation:pulseGlow 1.7s infinite;
    }
    @keyframes pulseGlow {
      0% { box-shadow:0 0 0 0 rgba(255,140,0,0.7); }
      70% { box-shadow:0 0 0 16px rgba(255,140,0,0); }
      100% { box-shadow:0 0 0 0 rgba(255,140,0,0); }
    }

    #status { max-width:420px; margin:8px auto 0; font-size:.98em; }

    /* Responsive tweaks */
    @media (max-width: 380px) {
      #game { gap:4px; padding:4px; }
      .tile { min-height:72px; font-size:1.7em; }
      .tile .score { font-size:.45em; right:4px; bottom:3px; }
      #settingsIcon { width:32px; height:32px; }
      #settingsIcon svg { width:16px; height:16px; }
    }
    @media (max-width: 330px) {
      .tile { min-height:64px; font-size:1.55em; }
    }
  </style>
</head>
<body>

<h1>Lexfall</h1>
<a id="settingsIcon" href="settings.html" aria-label="Settings" title="Settings">
  <!-- Inline SVG cog icon -->
  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
    <path d="M12 8.8a3.2 3.2 0 1 0 0 6.4 3.2 3.2 0 0 0 0-6.4zm9.4 3.2c0-.5 0-.9-.1-1.3l2-1.6-2-3.4-2.4 1a8.8 8.8 0 0 0-2.2-1.3l-.3-2.6H9.6l-.3 2.6a8.8 8.8 0 0 0-2.2 1.3l-2.4-1-2 3.4 2 1.6c0 .4-.1 .8-.1 1.3s0 .9 .1 1.3l-2 1.6 2 3.4 2.4-1c.7 .5 1.4 .9 2.2 1.3l.3 2.6h4.6l.3-2.6c.8-.4 1.5-.8 2.2-1.3l2.4 1 2-3.4-2-1.6c.1-.4 .1-.8 .1-1.3zM12 6.6a5.4 5.4 0 1 1 0 10.8A5.4 5.4 0 0 1 12 6.6z"/>
  </svg>
</a>
<div id="hud">
  <div id="wordDisplay">Word:</div>
  <div id="scoreDisplay">Score: 0</div>
  <div id="turnsLeft">Turns Left: 10</div>
</div>
<div id="container">
  <div id="game"></div>
  <svg id="overlay"></svg>
</div>
<div id="controls">
  <button id="confirm">Confirm</button>
  <button id="reject">Clear</button>
  <button id="newGame">New Game</button>
</div>
<div id="status"></div>

<script>
// ---- Config ----
const ROWS = 4, COLS = 4;
const TILE_RADIUS_PX = 35; // virtual circle for selection
const MAX_WORD_LEN = 16;
const DEFAULT_TURNS = 10;
const LETTER_SCORES = {
  A:1, B:3, C:3, D:2, E:1, F:4, G:2, H:4, I:1, J:8,
  K:5, L:1, M:3, N:1, O:1, P:3, Q:10, R:1, S:1, T:1,
  U:1, V:4, W:4, X:8, Y:4, Z:10
};

// ---- DOM ----
const gameEl = document.getElementById('game');
const overlay = document.getElementById('overlay');
const wordDisplay = document.getElementById('wordDisplay');
const scoreDisplay = document.getElementById('scoreDisplay');
const turnsDisplay = document.getElementById('turnsLeft');
const statusEl = document.getElementById('status');
const btnConfirm = document.getElementById('confirm');
const btnReject = document.getElementById('reject');
const btnNewGame = document.getElementById('newGame');


// Attach pointer listeners to the grid container for reliable swipe selection
gameEl.addEventListener('pointerdown', (e) => { pointerDown(e); try { gameEl.setPointerCapture && gameEl.setPointerCapture(e.pointerId); } catch(_e){} }, { passive: false });
gameEl.addEventListener('pointermove', (e) => { pointerMove(e); }, { passive: false });
// ---- Game State ----
let grid = [], selectedTiles = [], score = 0, turns = DEFAULT_TURNS;
let pointerActive = false; let paused = false; let slidThisGesture = false;
let DICT = new Set();
let PREFIX = new Set();
let settings = { minLen: 3, autoConfirm: true };

// ---- Utils ----
function showStatus(html, type='info') {
  statusEl.innerHTML = '<div class="' + type + '">' + html + '</div>';
}
function clearStatus() { statusEl.innerHTML = ''; }

function saveState() {
  try {
    const letters = grid.map(row => row.map(cell => cell.letter));
    const state = { letters, score, turns };
    localStorage.setItem('lexfall_state', JSON.stringify(state));
  } catch (e) { /* ignore */ }
}

function loadState() {
  try {
    const raw = localStorage.getItem('lexfall_state');
    if (!raw) return false;
    const s = JSON.parse(raw);
    if (!s || !Array.isArray(s.letters) || typeof s.score !== 'number' || typeof s.turns !== 'number') return false;
    grid = s.letters.map((row) => row.map(letter => ({ letter, element: null })));
    score = s.score; turns = s.turns;
    return true;
  } catch (e) { return false; }
}

function loadSettings(){ try { const s = JSON.parse(localStorage.getItem('lexfall_settings')||'{}'); if (s && typeof s.minLen==='number') settings.minLen=Math.max(2,Math.min(16,s.minLen)); if (typeof s.autoConfirm==='boolean') settings.autoConfirm=s.autoConfirm; } catch(e){} }
function persistSettings(){ try { localStorage.setItem('lexfall_settings', JSON.stringify(settings)); } catch(e){} }

// Dynamic size for overlay SVG
function resizeOverlay() {
  const rect = gameEl.getBoundingClientRect();
  overlay.setAttribute('width', rect.width);
  overlay.setAttribute('height', rect.height);
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
}
window.addEventListener('resize', resizeOverlay);

// Letter randomizer (English-like frequency)
function randomLetter() {
  const letters = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";
  return letters[Math.floor(Math.random() * letters.length)];
}

// Build empty grid and tiles
function makeRandomGrid() {
  grid = [];
  for (let r = 0; r < ROWS; r++) {
    const row = [];
    for (let c = 0; c < COLS; c++) row.push({ letter: randomLetter(), element: null });
    grid.push(row);
  }
}

function renderGrid() {
  gameEl.innerHTML = '';
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.classList.add('empty');
      tile.dataset.row = r; tile.dataset.col = c;
      const ch = grid[r][c].letter || '';
      const val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  setTimeout(resizeOverlay, 40);
  updateWordDisplay();
  drawPath();
}

function isInBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
function alreadySelected(r, c) { return selectedTiles.some(([rr, cc]) => rr === r && cc === c); }
function isAdjacentForgiving(r, c, prevR, prevC) { return Math.abs(r - prevR) <= 1 && Math.abs(c - prevC) <= 1; }

function selectTile(r, c) {
  if (!isInBounds(r, c) || paused) return;
  if (alreadySelected(r, c)) return;
  if (!grid[r][c].letter) return;
  if (selectedTiles.length > 0) {
    const [pr, pc] = selectedTiles[selectedTiles.length - 1];
    if (!isAdjacentForgiving(r, c, pr, pc)) return;
  }
  selectedTiles.push([r, c]);
  grid[r][c].element.classList.add('selected');
  updateWordDisplay();
  drawPath();
}

function currentWord() { return selectedTiles.map(([r, c]) => grid[r][c].letter).join(''); }

function refreshSelectionStyles() {
  const up = currentWord().toUpperCase();
  const meetsLen = up.length >= settings.minLen;
  const isValid = up.length > 0 && DICT.has(up) && meetsLen;
  const isDead = up.length > 0 && !PREFIX.has(up);
  selectedTiles.forEach(([r, c]) => {
    const el = grid[r][c].element;
    el.classList.remove('valid','invalid');
    if (isValid) el.classList.add('valid');
    else if (isDead) el.classList.add('invalid');
  });
  // Toggle buttons
  btnConfirm.style.display = isValid ? 'inline-block' : 'none';
  btnReject.style.display = selectedTiles.length ? 'inline-block' : 'none';
}

function updateWordDisplay() {
  const word = currentWord();
  refreshSelectionStyles();
  if (!word.length) {
    wordDisplay.textContent = 'Word:';
  } else {
    const pts = calculateScore(word.toUpperCase());
    wordDisplay.textContent = 'Word: ' + word + ' (' + pts + ')';
  }
}

function calculateScore(word) { return [...word].reduce((acc, ch) => acc + (LETTER_SCORES[ch] || 0), 0); }

function confirmWord(force=false) {
  if (selectedTiles.length === 0 || turns === 0) return;
  const word = currentWord().toUpperCase();
  const meetsLen = word.length >= settings.minLen;
  if (!force && !(DICT.has(word) && meetsLen)) { rejectWord(); return; }
  const wordScore = calculateScore(word);
  score += wordScore; scoreDisplay.textContent = 'Score: ' + score;
  turns--; turnsDisplay.textContent = 'Turns Left: ' + turns;
  removeAndDropTiles();
  clearSelection();
  saveState();
  maybeFinishGame();
}

function showWellDone() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) grid[r][c].letter = '';
  }
  const row1 = ['W','E','L','L'];
  const row2 = ['D','O','N','E'];
  for (let c = 0; c < COLS; c++) { grid[1][c].letter = row1[c]; }
  for (let c = 0; c < COLS; c++) { grid[2][c].letter = row2[c]; }
  renderGrid();
}

function maybeFinishGame() {
  if (turns <= 0) {
    paused = true;
    showStatus('<strong>Congratulations!</strong> Final score: <strong>' + score + '</strong>.', 'success');
    showWellDone();
    btnNewGame.style.display = 'inline-block';
  }
}

function rejectWord() { clearSelection(); }

function clearSelection() {
  selectedTiles.forEach(([r, c]) => grid[r][c].element.classList.remove('selected','valid','invalid'));
  selectedTiles = [];
  updateWordDisplay();
  drawPath();
}

// Remove selected tiles, drop down, refill from top
function removeAndDropTiles() {
  // Remove
  selectedTiles.forEach(([r, c]) => grid[r][c].letter = null);
  // Drop down per column
  for (let c = 0; c < COLS; c++) {
    const letters = [];
    for (let r = ROWS - 1; r >= 0; r--) if (grid[r][c].letter) letters.push(grid[r][c].letter);
    for (let r = ROWS - 1; r >= 0; r--) grid[r][c].letter = letters[ROWS - 1 - r] || null;
    for (let r = 0; r < ROWS; r++) if (!grid[r][c].letter) grid[r][c].letter = randomLetter();
  }
  renderGrid();
  ensurePlayableOrReshuffle();
}

// --- Hit testing helpers ---
function getTileCenter(r, c) {
  const gridRect = gameEl.getBoundingClientRect();
  const tile = grid[r][c].element; const tileRect = tile.getBoundingClientRect();
  return { x: tileRect.left + tileRect.width / 2 - gridRect.left, y: tileRect.top + tileRect.height / 2 - gridRect.top };
}

function tileFromPointerEvent(e) {
  const gridRect = gameEl.getBoundingClientRect();
  const x = (e.touches ? e.touches[0].clientX : e.clientX) - gridRect.left;
  const y = (e.touches ? e.touches[0].clientY : e.clientY) - gridRect.top;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (!grid[r][c].letter) continue;
      const center = getTileCenter(r, c); const dx = x - center.x; const dy = y - center.y;
      if (Math.hypot(dx, dy) < TILE_RADIUS_PX) return [r, c];
    }
  }
  return null;
}

// --- Pointer interactions (auto confirm on slide end) ---
function pointerDown(e) {
  if (paused) return;
  e.preventDefault(); pointerActive = true; slidThisGesture = false;
  const tile = tileFromPointerEvent(e);
  if (tile) selectTile(...tile);
}

function pointerMove(e) {
  if (!pointerActive || paused) return;
  e.preventDefault(); const tile = tileFromPointerEvent(e); if (!tile) return;
  const [r, c] = tile;
  if (!alreadySelected(r, c)) {
    if (selectedTiles.length === 0) selectTile(r, c);
    else {
      const [pr, pc] = selectedTiles[selectedTiles.length - 1];
      if (isAdjacentForgiving(r, c, pr, pc)) { selectTile(r, c); slidThisGesture = true; }
    }
  }
}

document.addEventListener('pointerup', () => {
  if (!pointerActive) return; pointerActive = false;
  if (selectedTiles.length === 0) return;
  // auto-confirm on gesture end if selection exists
  const word = currentWord().toUpperCase();
  const meetsLen = word.length >= settings.minLen;
  if (settings.autoConfirm && DICT.has(word) && meetsLen) confirmWord(true); else if (settings.autoConfirm) rejectWord();
});

// --- Path drawing with SVG lines ---
function drawPath() {
  overlay.innerHTML = '';
  if (selectedTiles.length < 2) return;
  const points = selectedTiles.map(([r, c]) => getTileCenter(r, c));
  let path = '';
  for (let i = 0; i < points.length - 1; i++) {
    path += '<line x1="' + points[i].x + '" y1="' + points[i].y + '" x2="' + points[i+1].x + '" y2="' + points[i+1].y + '" stroke="var(--blue)" stroke-width="5" stroke-linecap="round"/>';
  }
  overlay.innerHTML = path;
}

// --- Dictionary loading ---
async function loadDictionary() {
  const res = await fetch('en-words.txt');
  const text = await res.text();
  text.split(/\r?\n/).forEach(w => {
    w = w.trim(); if (!w) return; const up = w.toUpperCase(); if (up.length > MAX_WORD_LEN) return;
    DICT.add(up);
    for (let i = 1; i <= up.length; i++) PREFIX.add(up.slice(0, i));
  });
}

// --- Playability check (ensure at least 1 valid word in grid) ---
function gridHasAnyWord() {
  const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
  const dirs = [-1, 0, 1];
  function dfs(r, c, prefix) {
    const next = prefix + grid[r][c].letter;
    const up = next.toUpperCase();
    if (!PREFIX.has(up)) return false;
    if (DICT.has(up)) return true; // found at least one
    visited[r][c] = true;
    for (let dr of dirs) for (let dc of dirs) {
      if (dr === 0 && dc === 0) continue;
      const nr = r + dr, nc = c + dc;
      if (isInBounds(nr, nc) && !visited[nr][nc]) {
        if (dfs(nr, nc, next)) { visited[r][c] = false; return true; }
      }
    }
    visited[r][c] = false; return false;
  }
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (dfs(r, c, '')) return true;
    }
  }
  return false;
}

function ensurePlayableOrReshuffle() {
  if (gridHasAnyWord()) { clearStatus(); saveState(); return; }
  paused = true; btnConfirm.disabled = true; btnReject.disabled = true;
  showStatus('<strong>No words found</strong>, reshuffling...', 'warn');
  let attempts = 0;
  const tryReshuffle = () => {
    attempts++;
    makeRandomGrid(); renderGrid();
    if (gridHasAnyWord() || attempts > 50) {
      paused = false; btnConfirm.disabled = false; btnReject.disabled = false; clearStatus(); saveState();
    } else {
      setTimeout(tryReshuffle, 0);
    }
  };
  tryReshuffle();
}

// ---- Controls ----
btnConfirm.addEventListener('click', () => confirmWord());
btnReject.addEventListener('click', rejectWord);
btnNewGame.addEventListener('click', () => {
  score = 0; turns = DEFAULT_TURNS; scoreDisplay.textContent = 'Score: ' + score; turnsDisplay.textContent = 'Turns Left: ' + turns;
  makeRandomGrid(); renderGrid(); clearSelection(); paused = false; btnNewGame.style.display = 'none'; clearStatus(); ensurePlayableOrReshuffle(); saveState();
});

// ---- Boot ----
(async function init(){
  loadSettings();
  await loadDictionary();
  const restored = loadState();
  if (!restored) makeRandomGrid();
  renderGrid();
  scoreDisplay.textContent = 'Score: ' + score;
  turnsDisplay.textContent = 'Turns Left: ' + turns;
  resizeOverlay();
  ensurePlayableOrReshuffle();
})();
</script>
</body>
</html>
