<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Lexfall</title>
  <style>
  /* Legacy-friendly styles: no CSS variables, flex fallback by default */
  /* Ensure predictable sizing and prevent subtle overflow on mobile */
  *, *::before, *::after { box-sizing: border-box; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; margin:0; padding:12px; background:#f0f0f0; }
  h1 { margin:6px 0 4px; font-size:1.25rem; }

  /* No-anim global kill switch (for e-ink / low-end) */
  .no-anim *, .no-anim .tile, .no-anim .confetti { animation: none !important; transition: none !important; }
  /* Opacity settings for noanim mode to limit rerendering artifacts */
  .no-anim .tile { opacity: 1 !important; }
  .no-anim .tile.empty { opacity: 0 !important; }

  /* High contrast mode for better visibility on e-ink devices */
  .high-contrast {
    background: #ffffff !important;
    color: #000000 !important;
  }
  .high-contrast h1,
  .high-contrast #wordDisplay,
  .high-contrast #scoreDisplay,
  .high-contrast #turnsLeft {
    color: #000000 !important;
  }
  .high-contrast #game {
    background: #ffffff !important;
    border: 3px solid #000000 !important;
  }
  .high-contrast .tile {
    background: transparent !important;
    border: 3px solid #000000 !important;
    color: #000000 !important;
    font-weight: 900 !important;
  }
  .high-contrast .tile.selected {
    background: #777777 !important;
    color: #ffffff !important;
    border: 3px dashed #ffffff !important;
  }
  .high-contrast .tile.selected.valid {
    background: #000000 !important;
    color: #ffffff !important;
    border: 3px dotted #ffffff !important;
  }
  .high-contrast .tile.selected.invalid {
    background: #777777 !important;
    color: #ffffff !important;
    border: 3px dashed #ffffff !important;
  }
  .high-contrast .tile.empty {
    background: #ffffff !important;
    border: 2px dashed #cccccc !important;
    opacity: 0 !important;
  }
  .high-contrast button {
    background: #000000 !important;
    color: #ffffff !important;
    border: 3px solid #000000 !important;
    font-weight: bold !important;
  }
  .high-contrast #confirm {
    background: #000000 !important;
    color: #ffffff !important;
  }
  .high-contrast #reject {
    background: #666666 !important;
    color: #ffffff !important;
  }
  .high-contrast #newGame {
    background: #000000 !important;
    color: #ffffff !important;
    border: 4px solid #000000 !important;
  }

  /* Theming
     - Auto: handled by prefers-color-scheme (added again at end to ensure override order)
     - Force: use .theme-dark or .theme-light classes on body
  */
  .theme-dark body, body.theme-dark { background:#0f1115; color:#e5e7eb; }
  .theme-dark #game, body.theme-dark #game { background:#1a1f29; }
  .theme-dark .tile, body.theme-dark .tile { background:#111827; border-color:#2a3342; color:#e5e7eb; }
  .theme-dark .tile.empty, body.theme-dark .tile.empty { background:#0f1115; border-color:#253043; }
  .theme-dark .tile.selected, body.theme-dark .tile.selected { background:#1f2a3a; border-color:#3c4b63; }
  .theme-dark .tile.selected.valid, body.theme-dark .tile.selected.valid { background:#124e2e; border-color:#2bb673; }
  .theme-dark .tile.selected.invalid, body.theme-dark .tile.selected.invalid { background:#4a1f27; border-color:#dc3545; }
  .theme-dark #status, body.theme-dark #status { color:#cbd5e1; }
  .theme-dark #wordsList h3, body.theme-dark #wordsList h3 { color:#e5e7eb; }
  .theme-dark .word-entry, body.theme-dark .word-entry { background:#0f172a; border-color:#273449; color:#e5e7eb; }
  .theme-dark .word-entry a, body.theme-dark .word-entry a { color:#7dd3fc; }
  .theme-dark .word-score, body.theme-dark .word-score { color:#9ca3af; }
  .theme-dark #settingsIcon, body.theme-dark #settingsIcon { background:#1f2937; border-color:#374151; }
  .theme-dark #settingsIcon svg, body.theme-dark #settingsIcon svg { fill:#e5e7eb; }
  .theme-dark #themeToggle, body.theme-dark #themeToggle { background:#1f2937; border-color:#374151; color:#e5e7eb; }
  .theme-dark #version, body.theme-dark #version { color:#9ca3af; }

  /* Force light overrides when OS is dark */
  .theme-light body, body.theme-light { background:#f0f0f0; color:#111; }
  .theme-light #game, body.theme-light #game { background:#e0e0e0; }
  .theme-light .tile, body.theme-light .tile { background:#ffffff; border-color:#cccccc; color:#111; }
  .theme-light .tile.empty, body.theme-light .tile.empty { background:#f9f9f9; border-color:#dddddd; }
  .theme-light .tile.selected, body.theme-light .tile.selected { background:#e8f0ff; border-color:#cccccc; }
  .theme-light .tile.selected.valid, body.theme-light .tile.selected.valid { background:#bff0cf; border-color:#3bb273; }
  .theme-light .tile.selected.invalid, body.theme-light .tile.selected.invalid { background:#ffecec; border-color:#dc3545; }
  .theme-light #status, body.theme-light #status { color:#333; }
  .theme-light #wordsList h3, body.theme-light #wordsList h3 { color:#333; }
  .theme-light .word-entry, body.theme-light .word-entry { background:#f8f9fa; border-color:#dee2e6; color:#111; }
  .theme-light .word-entry a, body.theme-light .word-entry a { color:#007bff; }
  .theme-light .word-score, body.theme-light .word-score { color:#666; }
  .theme-light #settingsIcon, body.theme-light #settingsIcon { background:#ffffff; border-color:#cccccc; }
  .theme-light #settingsIcon svg, body.theme-light #settingsIcon svg { fill:#333333; }
  .theme-light #themeToggle, body.theme-light #themeToggle { background:#ffffff; border-color:#cccccc; color:#333333; }
  .theme-light #version, body.theme-light #version { color:#666; }


  #container { position:relative; width:100%; max-width:420px; margin:0 auto; }

  /* Fixed settings icon */
  #settingsIcon {
    position:fixed; top:8px; right:8px; width:36px; height:36px;
    display:inline-flex; align-items:center; justify-content:center;
    background:#ffffff; border:2px solid #cccccc; border-radius:50%;
    text-decoration:none; z-index:9999; box-shadow:0 1px 2px rgba(0,0,0,0.08);
  }
  #settingsIcon svg { width:18px; height:18px; fill:#333333; }

  /* Quick theme toggle (non-Kindle) */
  #themeToggle {
    position:fixed; top:8px; right:52px; width:36px; height:36px;
    display:inline-flex; align-items:center; justify-content:center;
    background:#ffffff; border:2px solid #cccccc; border-radius:50%;
    text-decoration:none; z-index:9999; box-shadow:0 1px 2px rgba(0,0,0,0.08);
    cursor:pointer; font-weight:800; font-size:0.9rem; color:#333333;
  }

  /* HUD */
  #hud { max-width:420px; margin:8px auto 10px; }
  #wordDisplay { font-weight:700; margin-bottom:4px; }
  #scoreDisplay, #turnsLeft { display:inline-block; width:49%; font-size:0.95rem; }

  /* Game: flex fallback (default) */
  #game {
    display:flex;
    flex-wrap:wrap;
    /* Center rows in flex fallback to avoid edge-touching on some mobiles */
    justify-content:center;
    width:100%;
    position:relative;
    background:#e0e0e0;
    border-radius:12px;
    padding:6px;
    min-height:340px; /* ensures visibility if JS sizing fails, extra height for e-ink devices */
  }

  .tile {
    background:#ffffff;
    border:2px solid #cccccc;
    font-size:2.1em;
    font-weight:800;
    user-select:none;
    border-radius:12px;
    transition:background .15s;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    touch-action:none;
    width:calc(25% - 8px);
    margin:4px;
    /* height will be set equal to width via JS to make squares */
    overflow:hidden;
  }
  
  /* Enhanced animations for capable browsers */
  .enhanced .tile {
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1), background 0.15s;
  }
  .enhanced .tile:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .enhanced .tile.selected {
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  }
  
  /* Tile removal animations */
  .enhanced .tile.removing {
    animation: tileRemove 0.4s cubic-bezier(0.4, 0, 1, 1) forwards;
  }
  .enhanced .tile.dropping {
    animation: tileDrop 0.6s cubic-bezier(0.2, 0.8, 0.4, 1) forwards;
  }
  .enhanced .tile.spawning {
    animation: tileSpawn 0.5s cubic-bezier(0.2, 0.8, 0.4, 1) forwards;
  }
  
  @keyframes tileRemove {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(0.8) rotateZ(10deg); opacity: 0.5; }
    100% { transform: scale(0); opacity: 0; }
  }
  
  @keyframes tileDrop {
    from { transform: translateY(-100px) scale(0.9); opacity: 0.7; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }
  
  @keyframes tileSpawn {
    from { transform: scale(0) rotateZ(180deg); opacity: 0; }
    60% { transform: scale(1.1) rotateZ(0deg); opacity: 0.8; }
    to { transform: scale(1) rotateZ(0deg); opacity: 1; }
  }
  
  /* Game completion effects */
  .enhanced .celebration {
    animation: celebrate 2s ease-in-out infinite;
  }
  
  .enhanced .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    border-radius: 50%;
    animation: confettiFall 3s linear infinite;
  }
  
  .enhanced .confetti:nth-child(2n) { background: #4ecdc4; animation-delay: 0.5s; }
  .enhanced .confetti:nth-child(3n) { background: #45b7d1; animation-delay: 1s; }
  .enhanced .confetti:nth-child(4n) { background: #96ceb4; animation-delay: 1.5s; }
  .enhanced .confetti:nth-child(5n) { background: #ffd93d; animation-delay: 2s; }
  
  @keyframes celebrate {
    0%, 100% { transform: scale(1) rotateZ(0deg); }
    25% { transform: scale(1.1) rotateZ(5deg); }
    75% { transform: scale(1.1) rotateZ(-5deg); }
  }
  
  @keyframes confettiFall {
    0% {
      transform: translateY(-100vh) rotateZ(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotateZ(720deg);
      opacity: 0;
    }
  }
  
  /* Enhanced game completion background effect */
  .enhanced .game-complete {
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffd93d);
    background-size: 400% 400%;
    animation: gradientShift 3s ease infinite;
    border-radius: 20px;
  }
  
  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  .tile.selected { background:#e8f0ff; border-color:#cccccc; }
  .tile.selected.valid { background:#bff0cf; border-color:#3bb273; }
  .tile.selected.invalid { background:#ffecec; border-color:#dc3545; }
  .tile.empty { background:#f9f9f9; border:2px dashed #dddddd; }
  .tile .score { position:absolute; right:6px; bottom:4px; font-size:.5em; opacity:.8; }

  #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }

  #controls { display:flex; justify-content:center; gap:10px; margin:10px auto; }
  button { padding:.9em 1.1em; margin:.2em; font-size:1em; border-radius:10px; border:none; cursor:pointer; }
  #confirm { background:#3bb273; color:#fff; display:none; }
  #reject { background:#dc3545; color:#fff; display:none; }
  
  /* New Game emphasis */
  #newGame {
    background:#ff8c00; color:#fff; font-weight:bold;
    border:2px solid #e67e00;
  }
  @keyframes pulseGlow {
    0% { box-shadow:0 0 0 0 rgba(255,140,0,0.7); }
    70% { box-shadow:0 0 0 16px rgba(255,140,0,0); }
    100% { box-shadow:0 0 0 0 rgba(255,140,0,0); }
  }

  #status { max-width:420px; margin:8px auto 0; font-size:.98em; }
  .dict-loading { color:#666; font-size:0.8em; font-style:italic; }
  #version { position:fixed; bottom:8px; right:8px; font-size:0.75em; color:#666; z-index:1000; }

  /* Words list */
  #wordsList { max-width:420px; margin:12px auto; text-align:center; }
  #wordsList h3 { margin:0 0 8px; font-size:1rem; color:#333; }
  #wordsContainer { text-align:left; }
  .word-entry { display:inline-block; margin:2px 4px; padding:4px 8px; background:#f8f9fa; border:1px solid #dee2e6; border-radius:6px; font-size:0.85em; }
  .word-entry a { text-decoration:none; color:#007bff; font-weight:600; }
  .word-entry a:hover { text-decoration:underline; }
  .word-score { color:#666; margin-left:4px; font-size:0.9em; }
  
  /* High contrast mode for words list */
  .high-contrast #wordsList h3 { color:#000; }
  .high-contrast .word-entry { background:#ffffff; border:2px solid #000; color:#000; }
  .high-contrast .word-entry a { color:#000; }
  .high-contrast .word-score { color:#333; }

  /* Debug log - hidden by default */
  #debugLog { max-width:420px; margin:8px auto; text-align:left; font:12px/1.3 monospace; background:#ffffff; color:#000; border:1px solid #cccccc; padding:6px; border-radius:6px; display:none; }
  .debug-mode #debugLog { display:block; }

  /* If CSS Grid is supported, use it */
  @supports (display: grid) {
    #game {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:6px;
      padding:6px;
    }
    .tile { width:auto; margin:0; }
  }

  /* Responsive tweaks */
  @media (max-width: 380px) {
    .tile { font-size:1.7em; }
    #settingsIcon, #themeToggle { width:32px; height:32px; }
    #settingsIcon svg { width:16px; height:16px; }
    #themeToggle { font-size:0.85rem; }
  }
  @media (max-width: 330px) {
    .tile { font-size:1.55em; }
    #settingsIcon, #themeToggle { width:30px; height:30px; top:6px; }
    #settingsIcon svg { width:15px; height:15px; }
    #themeToggle { font-size:0.8rem; right:48px; }
  }
  
  /* Auto theme: place after base styles so it wins in cascade */
  @media (prefers-color-scheme: dark) {
    body { background:#0f1115; color:#e5e7eb; }
    #game { background:#1a1f29; }
    .tile { background:#111827; border-color:#2a3342; color:#e5e7eb; }
    .tile.empty { background:#0f1115; border-color:#253043; }
    .tile.selected { background:#1f2a3a; border-color:#3c4b63; }
    .tile.selected.valid { background:#124e2e; border-color:#2bb673; }
    .tile.selected.invalid { background:#4a1f27; border-color:#dc3545; }
    #status { color:#cbd5e1; }
    #wordsList h3 { color:#e5e7eb; }
    .word-entry { background:#0f172a; border-color:#273449; color:#e5e7eb; }
    .word-entry a { color:#7dd3fc; }
    .word-score { color:#9ca3af; }
    #settingsIcon { background:#1f2937; border-color:#374151; }
    #settingsIcon svg { fill:#e5e7eb; }
    #themeToggle { background:#1f2937; border-color:#374151; color:#e5e7eb; }
    #version { color:#9ca3af; }
  }
</style>
</head>
<body>

<h1>Lexfall</h1>
<a id="settingsIcon" href="settings.html" aria-label="Settings" title="Settings">
  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
    <path d="M12 8.8a3.2 3.2 0 1 0 0 6.4 3.2 3.2 0 0 0 0-6.4zm9.4 3.2c0-.5 0-.9-.1-1.3l2-1.6-2-3.4-2.4 1a8.8 8.8 0 0 0-2.2-1.3l-.3-2.6H9.6l-.3 2.6a8.8 8.8 0 0 0-2.2 1.3l-2.4-1-2 3.4 2 1.6c0 .4-.1 .8-.1 1.3s0 .9 .1 1.3l-2 1.6 2 3.4 2.4-1c.7 .5 1.4 .9 2.2 1.3l.3 2.6h4.6l.3-2.6c.8-.4 1.5-.8 2.2-1.3l2.4 1 2-3.4-2-1.6c.1-.4 .1-.8 .1-1.3zM12 6.6a5.4 5.4 0 1 1 0 10.8A5.4 5.4 0 0 1 12 6.6z"/>
  </svg>
</a>
<button id="themeToggle" aria-label="Theme" title="Theme">A</button>
<div id="hud">
  <div id="wordDisplay">Word:</div>
  <div id="scoreDisplay">Score: 0</div>
  <div id="turnsLeft">Turns Left: 10</div>
</div>
<div id="container">
  <div id="game"></div>
  <svg id="overlay"></svg>
</div>
<div id="controls">
  <button id="confirm" type="button" onclick="confirmWord(true)">Confirm</button>
  <button id="reject">Clear</button>
  <button id="newGame">New Game</button>
</div>
<div id="status"></div>
<div id="wordsList">
  <h3>Accepted Words</h3>
  <div id="wordsContainer"></div>
</div>
<div id="debugLog" aria-live="polite"></div>
<div id="version">v1.2.3</div>

<script>
// --- Minimal polyfills for weak browsers ---
if (!('Math' in window && typeof Math.hypot === 'function')) {
  Math.hypot = function(){ var s=0; for (var i=0;i<arguments.length;i++){ var n=Number(arguments[i])||0; s+=n*n; } return Math.sqrt(s); };
}
if (typeof window.Set === 'undefined') {
  (function(){
    function SimpleSet(){ this._o = Object.create(null); }
    SimpleSet.prototype.add = function(v){ this._o[v] = 1; return this; };
    SimpleSet.prototype.has = function(v){ return !!this._o[v]; };
    window.Set = SimpleSet;
  })();
}

// ---- Config ----
var ROWS = 4, COLS = 4;
var TILE_RADIUS_PX = 35;
var MAX_WORD_LEN = 16;
var DEFAULT_TURNS = 10;
var LETTER_SCORES = {};

// ---- DOM ----
var gameEl = document.getElementById('game');
var overlay = document.getElementById('overlay');
var wordDisplay = document.getElementById('wordDisplay');
var scoreDisplay = document.getElementById('scoreDisplay');
var turnsDisplay = document.getElementById('turnsLeft');
var statusEl = document.getElementById('status');
var wordsContainer = document.getElementById('wordsContainer');
var btnConfirm = document.getElementById('confirm');
var btnReject = document.getElementById('reject');
var btnNewGame = document.getElementById('newGame');
var btnTheme = document.getElementById('themeToggle');

// Browser capability detection
var HAS_POINTER = !!window.PointerEvent;
var ENHANCED_BROWSER = (function() {
  try {
    // Check for modern CSS features and reasonable performance
    return !!(window.CSS && CSS.supports && 
             CSS.supports('transform', 'scale(1)') &&
             CSS.supports('transition', 'all 0.3s') &&
             CSS.supports('animation', 'none') &&
             window.requestAnimationFrame &&
             !navigator.userAgent.toLowerCase().includes('kindle'));
  } catch(e) { return false; }
})();
// Low-end animation switches
var LOW_END_MODE = (function(){ try { var ua=(navigator.userAgent||'').toLowerCase(); return /kindle|silk|kfw|kfa|kft|kfj|kfm|kfx|kfk|kfv|kfs|kfg|kfp/.test(ua); } catch(e){ return false; }})();
// ANIM will be determined after loading settings

// ---- Game State ----
var grid = [], selectedTiles = [], score = 0, turns = DEFAULT_TURNS;
var pointerActive = false, paused = false, slidThisGesture = false;
var selectionStartLen = 0; // NEW: selection size at the start of the gesture
var interactionMode = null; var lastSelectVia = null; // NEW: session-level input mode lock
var acceptedWords = []; // Track accepted words with scores
var DICT = new Set();
var PREFIX = new Set();
var dictionaryReady = false;
var settings = { autoConfirm: true, noAnim: false, highContrast: false, debug: false, theme: 'auto' };

// --- Debugging (controlled by settings) ---
var DEBUG = false; // Debug mode will be set from settings
function dbg(code, info){
  if(!DEBUG) return;
  try{
    var el=document.getElementById('debugLog'); if(!el) return;
    var t=(Date.now()%100000).toString(36);
    var line=(code||'?')+(info?' '+String(info):'');
    var d=document.createElement('div'); d.textContent=t+' '+line;
    el.insertBefore(d, el.firstChild);
    var max=60; while(el.childNodes.length>max) el.removeChild(el.lastChild);
  }catch(e){}
}
window.onerror=function(msg,src,ln,col,err){ try{ dbg('E', (msg||'')+' @'+ln+':'+col); }catch(_e){} };

// ---- Utils ----
var UPDATE_SUSPENDED = false;
function suspendUpdates(){ try{ UPDATE_SUSPENDED = true; if (gameEl) gameEl.style.visibility='hidden'; if (overlay) overlay.style.display='none'; dbg('BATCH','start'); }catch(e){} }
function resumeUpdates(){ try{ UPDATE_SUSPENDED = false; if (gameEl) gameEl.style.visibility='visible'; if (overlay) overlay.style.display='block'; dbg('BATCH','end'); }catch(e){} }

function showStatus(html, type){ statusEl.innerHTML = '<div class="' + (type||'info') + '">' + html + '</div>'; }
function clearStatus(){ statusEl.innerHTML = ''; }

function addWordToList(word, wordScore) {
  acceptedWords.push({ word: word, score: wordScore });
  updateWordsList();
}

function updateWordsList() {
  if (!wordsContainer) return;
  if (acceptedWords.length === 0) {
    wordsContainer.innerHTML = '<div style="text-align:center; color:#666; font-style:italic; padding:8px;">No words found yet</div>';
    return;
  }
  
  var html = '';
  for (var i = 0; i < acceptedWords.length; i++) {
    var entry = acceptedWords[i];
    var word = entry.word;
    var score = entry.score;
    var wiktionaryUrl = 'https://en.wiktionary.org/wiki/' + word.toLowerCase() + '#English';
    html += '<div class="word-entry">';
    html += '<a href="' + wiktionaryUrl + '" target="_blank" rel="noopener">' + word + '</a>';
    html += '<span class="word-score">(' + score + ')</span>';
    html += '</div>';
  }
  wordsContainer.innerHTML = html;
}

function saveState() {
  try {
    var letters = grid.map(function(row){ return row.map(function(cell){ return cell.letter; }); });
    var state = { letters: letters, score: score, turns: turns, acceptedWords: acceptedWords };
    localStorage.setItem('lexfall_state', JSON.stringify(state));
  } catch (e) {}
}

function loadState() {
  try {
    var raw = localStorage.getItem('lexfall_state');
    if (!raw) return false;
    var s = JSON.parse(raw);
    if (!s || !Array.isArray(s.letters) || typeof s.score !== 'number' || typeof s.turns !== 'number') return false;
    grid = [];
    for (var r=0; r<ROWS; r++){
      var row = [];
      for (var c=0; c<COLS; c++){
        var letter = (s.letters[r] && s.letters[r][c]) || null;
        // Sanitize: require A-Z single char, else random
        if (typeof letter !== 'string' || !/^[A-Z]$/.test(letter)) letter = randomLetter();
        row.push({ letter: letter, element: null });
      }
      grid.push(row);
    }
    score = s.score; turns = s.turns;
    // Load accepted words if they exist
    acceptedWords = Array.isArray(s.acceptedWords) ? s.acceptedWords : [];
    return true;
  } catch (e) { return false; }
}

function loadSettings(){
  try {
    var s = JSON.parse(localStorage.getItem('lexfall_settings')||'{}');
    // minLen removed; fixed at 2
    if (typeof s.autoConfirm==='boolean') settings.autoConfirm = s.autoConfirm;
    if (typeof s.noAnim==='boolean') settings.noAnim = s.noAnim;
    if (typeof s.highContrast==='boolean') settings.highContrast = s.highContrast;
    if (typeof s.theme==='string' && /^(light|auto|dark)$/.test(s.theme)) settings.theme = s.theme; else settings.theme = 'auto';
    if (typeof s.debug==='boolean') settings.debug = s.debug;
    
    // Update global variables based on settings
    DEBUG = settings.debug;
  } catch(e){}
}

// Maintain square grid for browsers without aspect-ratio
function sizeGridSquare(){
  try {
    var supportsAspect = (window.CSS && CSS.supports && CSS.supports('aspect-ratio', '1/1'));
    if (!supportsAspect) {
      var w = gameEl.clientWidth || 320;
      // Add extra height for Kindle/e-ink devices to prevent bottom row cutoff
      var extraHeight = LOW_END_MODE ? 20 : 12;
      gameEl.style.height = (w + extraHeight) + 'px';
    }
  } catch(e){}
  // Also size overlay to match
  var rect = gameEl.getBoundingClientRect();
  overlay.setAttribute('width', rect.width);
  overlay.setAttribute('height', rect.height);
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
}
window.addEventListener('resize', sizeGridSquare);

// Make tiles square for legacy browsers (no CSS aspect-ratio or grid)
function sizeTilesSquare(){
  try {
    var tiles = gameEl.getElementsByClassName('tile');
    if (!tiles || !tiles.length) return;
    for (var i=0;i<tiles.length;i++){
      var w = tiles[i].offsetWidth || 0;
      if (w > 0) { tiles[i].style.height = w + 'px'; }
    }
    // Sync overlay box to #game
    var rect = gameEl.getBoundingClientRect();
    overlay.setAttribute('width', rect.width);
    overlay.setAttribute('height', rect.height);
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
  } catch(e){}
}
window.addEventListener('resize', sizeTilesSquare);


// Letter randomizer
function randomLetter() {
  var letters = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";
  return letters[Math.floor(Math.random() * letters.length)];
}

// Build empty grid and tiles
function makeRandomGrid() {
  grid = [];
  for (var r = 0; r < ROWS; r++) {
    var row = [];
    for (var c = 0; c < COLS; c++) row.push({ letter: randomLetter(), element: null });
    grid.push(row);
  }
}

/**
 * Renders tiles in one atomic swap for non-animation mode to avoid flicker.
 * We construct a DocumentFragment off-DOM, then replace content for Kindle compatibility.
 */
function renderGridNoAnim() {
  var frag = document.createDocumentFragment();
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      frag.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  // Kindle-compatible: clear and append fragment
  gameEl.innerHTML = '';
  gameEl.appendChild(frag);
  // Defer sizing to next tick to let layout settle once
  setTimeout(function(){ sizeGridSquare(); sizeTilesSquare(); updateWordDisplay(); drawPath(); }, 0);
}

// Original simple renderer (used at boot and when ANIM==true)
function renderGrid() {
  if (!ANIM) { return renderGridNoAnim(); }
  gameEl.innerHTML = '';
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  setTimeout(sizeGridSquare, 0);
  setTimeout(sizeTilesSquare, 0);
  updateWordDisplay();
  drawPath();
}

function renderGridWithAnimations(newTiles, droppingTiles) {
  gameEl.innerHTML = '';
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
      
      // Add appropriate animations for enhanced browsers
      if (ANIM && ch) {
        var isNewTile = newTiles && newTiles.some(function(nt) { return nt[0] === r && nt[1] === c; });
        var isDroppingTile = droppingTiles && droppingTiles.some(function(dt) { return dt[0] === r && dt[1] === c; });
        
        if (isNewTile) {
          tile.classList.add('spawning');
          (function(t){ setTimeout(function(){ t.classList.remove('spawning'); }, 500); })(tile);
        } else if (isDroppingTile) {
          tile.classList.add('dropping');
          (function(t){ setTimeout(function(){ t.classList.remove('dropping'); }, 600); })(tile);
        }
      }
    }
  }
  setTimeout(sizeGridSquare, 0);
  setTimeout(sizeTilesSquare, 0);
  updateWordDisplay();
  drawPath();
}

function isInBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
function alreadySelected(r, c) { for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; if (t[0]===r && t[1]===c) return true; } return false; }
function isAdjacentForgiving(r, c, pr, pc) { return Math.abs(r - pr) <= 1 && Math.abs(c - pc) <= 1; }

function selectTile(r, c) {
  if (!isInBounds(r, c) || paused) return;
  if (!grid[r][c].letter) return;
  if (alreadySelected(r, c)) return;
  if (interactionMode === 'drag') return;
  
  // Always enforce adjacency for valid word formation
  if (selectedTiles.length > 0) {
    var last = selectedTiles[selectedTiles.length - 1];
    if (!isAdjacentForgiving(r, c, last[0], last[1])) return;
  }
  
  selectedTiles.push([r, c]);
  maybeLockInteractionMode();
  
  // Click/tap path: never auto-confirm/cancel
  grid[r][c].element.className += ' selected';
  updateWordDisplay();
  drawPath();
}

function selectTileForDrag(r, c) {
  if (interactionMode === 'tap') return;
  if (!isInBounds(r, c) || paused) return;
  if (alreadySelected(r, c)) return;
  if (!grid[r][c].letter) return;
  
  // Always enforce adjacency for valid word formation
  if (selectedTiles.length > 0) {
    var last = selectedTiles[selectedTiles.length - 1];
    if (!isAdjacentForgiving(r, c, last[0], last[1])) return;
  }
  
  selectedTiles.push([r, c]);
  maybeLockInteractionMode();
  
  // NOTE: We intentionally DO NOT set slidThisGesture here.
  // Drag is detected only when selection grows during pointerMove.
  
  grid[r][c].element.className += ' selected';
  updateWordDisplay();
  drawPath();
}

function maybeLockInteractionMode() {
  if (interactionMode) return;
  if (selectedTiles.length >= 2) {
    interactionMode = (lastSelectVia === 'drag' || pointerActive) ? 'drag' : 'tap';
  }
}

function currentWord() {
  var out = '';
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; out += grid[t[0]][t[1]].letter; }
  return out;
}

function refreshSelectionStyles() {
  var up = currentWord().toUpperCase();
  var meetsLen = up.length >= 2;
  var isValid = up.length > 0 && meetsLen && (dictionaryReady ? DICT.has(up) : true);
  var isDead = dictionaryReady && up.length > 0 && !PREFIX.has(up);
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bvalid\b|\binvalid\b/g, '').trim();
    if (isValid) el.className += ' valid';
    else if (isDead) el.className += ' invalid';
  }
  var canConfirm = (turns > 0) && (dictionaryReady ? isValid : meetsLen);
  btnConfirm.style.display = canConfirm ? 'inline-block' : 'none';
  btnConfirm.disabled = false;
  btnReject.style.display = selectedTiles.length ? 'inline-block' : 'none';
}

function updateWordDisplay() {
  var word = currentWord();
  refreshSelectionStyles();
  if (!word.length) wordDisplay.textContent = 'Word:';
  else {
    var upperWord = word.toUpperCase();
    var baseScore = 0;
    for (var i=0;i<upperWord.length;i++){ var ch = upperWord.charAt(i); baseScore += LETTER_SCORES[ch] || 0; }
    var lengthMultiplier = calculateLengthMultiplier(upperWord.length);
    var pts = calculateScore(upperWord);
    
    if (lengthMultiplier > 1) {
      wordDisplay.textContent = 'Word: ' + word + ' (' + baseScore + ' × ' + lengthMultiplier + ' = ' + pts + ')';
    } else {
      wordDisplay.textContent = 'Word: ' + word + ' (' + pts + ')';
    }
  }
}

function calculateLengthMultiplier(wordLength) {
  if (wordLength <= 4) return 1;
  return wordLength - 3;
}

function calculateScore(word) {
  var acc = 0;
  for (var i=0;i<word.length;i++){ var ch = word.charAt(i); acc += LETTER_SCORES[ch] || 0; }
  var lengthMultiplier = calculateLengthMultiplier(word.length);
  return acc * lengthMultiplier;
}

function confirmWord(force) {
  dbg('CF_START','sel='+selectedTiles.length+' t='+turns);
  if (selectedTiles.length === 0) { dbg('CF0','empty'); return; }
  if (turns === 0) { dbg('CF0','turns0'); return; }
  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= 2;
  if (!force && !((dictionaryReady ? DICT.has(word) : true) && meetsLen)) { dbg('CFX', word); dbg('AUTO_X', word);
    rejectWord(); return; }
  var wordScore = calculateScore(word);
  score += wordScore; scoreDisplay.textContent = 'Score: ' + score;
  turns--; turnsDisplay.textContent = 'Turns Left: ' + turns;
  addWordToList(word, wordScore);
  dbg('CFOK', word + ' +' + wordScore + ' S=' + score + ' T=' + turns);
  
  // Check if game should end BEFORE processing tile removal
  if (turns <= 0) {
    // Game is ending - clear selection and show end game immediately
    clearSelection();
    paused = true;
    showStatus('<strong>Congratulations!</strong> Final score: <strong>' + score + '</strong>.', 'success');
    showWellDone();
    dbg('END','T0');
    saveState();
    return;
  }
  
  // Game continues - process tile removal normally
  dbg('RMD_CALL');
  removeAndDropTiles();
  saveState();
}

function showWellDone() {
  // Clear all tiles properly - set to empty string instead of null to avoid empty class
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      grid[r][c].letter = '';
    }
  }
  
  // Set WELL DONE letters in center rows
  var row1 = ['W','E','L','L'];
  var row2 = ['D','O','N','E'];
  for (var c = 0; c < COLS; c++) { 
    grid[1][c].letter = row1[c]; 
    grid[2][c].letter = row2[c]; 
  }
  
  // Render the grid with WELL DONE tiles and empty tiles elsewhere
  renderGrid();
  
  // Hide empty tiles and show only WELL DONE tiles
  setTimeout(function() {
    var tiles = gameEl.getElementsByClassName('tile');
    for (var i = 0; i < tiles.length; i++) {
      var tile = tiles[i];
      var row = parseInt(tile.getAttribute('data-row'), 10);
      var col = parseInt(tile.getAttribute('data-col'), 10);
      
      if ((row === 1 || row === 2) && grid[row][col].letter) {
        // Show WELL DONE tiles
        tile.style.visibility = 'visible';
        tile.style.opacity = '1';
      } else {
        // Hide all other tiles
        tile.style.visibility = 'hidden';
        tile.style.opacity = '0';
      }
    }
  }, 50);
  
  if (ANIM) {
    // Add celebration effects
    gameEl.classList.add('game-complete');
    
    // Add celebration class to WELL DONE tiles after they're made visible
    setTimeout(function() {
      var tiles = gameEl.getElementsByClassName('tile');
      for (var i = 0; i < tiles.length; i++) {
        var tile = tiles[i];
        var row = parseInt(tile.getAttribute('data-row'), 10);
        var col = parseInt(tile.getAttribute('data-col'), 10);
        
        // Only animate tiles that have WELL DONE letters (rows 1 and 2)
        if ((row === 1 || row === 2) && grid[row][col].letter) {
          tile.classList.add('celebration');
        }
      }
    }, 150);
    
    // Create confetti effect
    createConfetti();
  }
}

function createConfetti() {
  if (!ANIM) return;
  
  var container = document.getElementById('container');
  var confettiCount = 50;
  
  for (var i = 0; i < confettiCount; i++) {
    var confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 3 + 's';
    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
    container.appendChild(confetti);
    
    // Remove confetti after animation
    setTimeout(function(c) {
      if (c.parentNode) c.parentNode.removeChild(c);
    }, 5000, confetti);
  }
}

function maybeFinishGame() {
  // This function is now handled in confirmWord() to prevent tile processing after game ends
  // Kept for any future use cases where we might need to check game end from other contexts
  if (turns <= 0) {
    paused = true;
    showStatus('<strong>Congratulations!</strong> Final score: <strong>' + score + '</strong>.', 'success');
    showWellDone();
  }
}

function rejectWord() { clearSelection(); }

function clearSelection() {
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bselected\b|\bvalid\b|\binvalid\b/g,'').trim();
  }
  selectedTiles = [];
  interactionMode = null; lastSelectVia = null;
  updateWordDisplay();
  drawPath();
}

function applyThemeFromSettings() {
  var useHighContrast = settings.highContrast || settings.noAnim || LOW_END_MODE;
  document.body.classList.remove('theme-dark','theme-light');
  if (useHighContrast) return; // high contrast overrides theme
  if (settings.theme === 'dark') document.body.classList.add('theme-dark');
  else if (settings.theme === 'light') document.body.classList.add('theme-light');
}

function updateThemeToggleGlyph() {
  if (!btnTheme) return;
  var ch = 'A';
  if (settings && settings.theme === 'dark') ch = 'D';
  else if (settings && settings.theme === 'light') ch = 'L';
  btnTheme.textContent = ch;
}

// Remove selected tiles, drop down, refill from top
function removeAndDropTiles() {
  dbg('RMD', ANIM?'anim':'instant');
  if (ANIM) {
    // Animate removal first
    for (var i = 0; i < selectedTiles.length; i++) {
      var rc = selectedTiles[i];
      var tile = grid[rc[0]][rc[1]].element;
      tile.classList.add('removing');
    }
    
    // Wait for removal animation, then drop and refill
    setTimeout(function() {
      performTileDropAndRefill();
    }, 400);
  } else {
    // Non-animation mode: avoid flicker by doing atomic DOM swap only
    performTileDropAndRefill();
  }
}

function performTileDropAndRefill() {
  dbg('DROP','start');
  // Store which tiles were selected before removing them
  var affectedColumns = {};
  for (var i = 0; i < selectedTiles.length; i++) {
    affectedColumns[selectedTiles[i][1]] = true;
  }
  
  // Store original positions of all tiles before any changes
  var originalPositions = {};
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      if (grid[r][c].letter) {
        var key = grid[r][c].letter + '_' + r + '_' + c + '_' + Math.random();
        originalPositions[key] = { letter: grid[r][c].letter, row: r, col: c };
      }
    }
  }
  
  // Remove selected tiles
  for (var i=0;i<selectedTiles.length;i++){ var rc = selectedTiles[i]; grid[rc[0]][rc[1]].letter = null; }
  
  // Clear selection now that tiles are removed
  clearSelection();
  
  // Drop down per column and track new positions
  var newTiles = [];
  var droppingTiles = [];
  
  for (var c = 0; c < COLS; c++) {
    if (!affectedColumns[c]) continue; // Skip columns that weren't affected
    
    // Collect existing letters with their original positions
    var lettersWithPositions = [];
    for (var r = ROWS - 1; r >= 0; r--) {
      if (grid[r][c].letter) {
        lettersWithPositions.push({ letter: grid[r][c].letter, originalRow: r });
      }
    }
    
    // Clear the column
    for (var r = 0; r < ROWS; r++) {
      grid[r][c].letter = null;
    }
    
    // Place existing letters at bottom and track if they actually moved
    for (var i = 0; i < lettersWithPositions.length; i++) {
      var newRow = ROWS - 1 - i;
      grid[newRow][c].letter = lettersWithPositions[i].letter;
      
      // Only animate if the tile actually moved down from its original position
      if (ENHANCED_BROWSER && lettersWithPositions[i].originalRow < newRow) {
        droppingTiles.push([newRow, c]);
      }
    }
    
    // Fill empty spaces at top with new letters
    for (var r = 0; r < ROWS - lettersWithPositions.length; r++) {
      grid[r][c].letter = randomLetter();
      if (ANIM) {
        newTiles.push([r, c]);
      }
    }
  }
  
  if (ANIM) {
    renderGridWithAnimations(newTiles, droppingTiles);
  } else {
    renderGridNoAnim();
  }
  
  dbg('RENDER', ANIM?'anim':'none');
  ensurePlayableOrReshuffle();
}

// --- Hit testing helpers ---
function getTileCenter(r, c) {
  var gridRect = gameEl.getBoundingClientRect();
  var tile = grid[r][c].element; var tileRect = tile.getBoundingClientRect();
  return { x: tileRect.left + tileRect.width / 2 - gridRect.left, y: tileRect.top + tileRect.height / 2 - gridRect.top };
}

function tileFromPointerEvent(e) {
  var gridRect = gameEl.getBoundingClientRect();
  var clientX = (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
  var clientY = (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);
  var x = clientX - gridRect.left;
  var y = clientY - gridRect.top;
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      if (!grid[r][c].letter) continue;
      var center = getTileCenter(r, c); var dx = x - center.x; var dy = y - center.y;
      if (Math.hypot(dx, dy) < TILE_RADIUS_PX) return [r, c];
    }
  }
  return null;
}

// --- Pointer interactions ---
function pointerDown(e) {
  dbg('PD');
  if (paused || preventPointerEvents) return;
  if (e && e.preventDefault) e.preventDefault();
  pointerActive = true; slidThisGesture = false;
  selectionStartLen = selectedTiles.length; // NEW: snapshot length at start of gesture
  var tile = tileFromPointerEvent(e);
  if (tile) { lastSelectVia='drag'; selectTileForDrag(tile[0], tile[1]); }
}

function pointerMove(e) {
  if (!pointerActive || paused || preventPointerEvents) return;
  if (e && e.preventDefault) e.preventDefault();
  var preLen = selectedTiles.length; // track length before this move
  var tile = tileFromPointerEvent(e); if (!tile) return;
  var r = tile[0], c = tile[1];
  
  // Check if this tile is already selected
  var selectedIndex = -1;
  for (var i = 0; i < selectedTiles.length; i++) {
    if (selectedTiles[i][0] === r && selectedTiles[i][1] === c) {
      selectedIndex = i;
      break;
    }
  }
  
  if (selectedIndex !== -1) {
    // Tile is already selected - allow retracing by unselecting tiles after this one
    if (selectedIndex < selectedTiles.length - 1) {
      // Remove all tiles after this one (retrace back to this tile)
      for (var i = selectedIndex + 1; i < selectedTiles.length; i++) {
        var rc = selectedTiles[i];
        var el = grid[rc[0]][rc[1]].element;
        el.className = el.className.replace(/\bselected\b|\bvalid\b|\binvalid\b/g, '').trim();
      }
      selectedTiles = selectedTiles.slice(0, selectedIndex + 1);
      updateWordDisplay();
      drawPath();
    }
  } else {
    // Tile is not selected - try to select it
    if (selectedTiles.length === 0) { lastSelectVia='drag'; selectTileForDrag(r, c); }
    else {
      var last = selectedTiles[selectedTiles.length - 1];
      if (isAdjacentForgiving(r, c, last[0], last[1])) { 
        lastSelectVia='drag'; selectTileForDrag(r, c); 
      }
    }
  }

  // NEW: mark this as a slide only if selection grew during movement
  if (!slidThisGesture && selectedTiles.length > preLen) {
    slidThisGesture = true;
  }
  dbg('PM','len='+selectedTiles.length+(slidThisGesture?'/s':''));
}

function onGestureEnd(){
  if (!pointerActive || preventPointerEvents) return;
  pointerActive = false;
  var wasSlide = !!slidThisGesture;
  dbg('GE', wasSlide ? 'slide' : 'tap');
  slidThisGesture = false;
  
  // For taps, do nothing - let the user build words manually
  if (!wasSlide) return;

  // Only auto-confirm/cancel for slide gestures
  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= 2;
  if (!settings.autoConfirm) return;

  var ok = dictionaryReady ? DICT.has(word) : true;
  if (meetsLen && ok) { 
    // Auto-confirm immediately for slide gestures only
    dbg('AUTO_OK', word);
    confirmWord(true);
  } else if (dictionaryReady) { 
    // Only auto-cancel when we know it's invalid via dictionary, and only for slides
    rejectWord();
  }
}

// Attach listeners
// Simple closest polyfill
function closestEl(el, selector){
  while (el && el.nodeType === 1){
    if ((el.matches && el.matches(selector)) || (el.msMatchesSelector && el.msMatchesSelector(selector))) return el;
    el = el.parentNode;
  }
  return null;
}
// Simple click handler for tile selection
var preventPointerEvents = false;

gameEl.addEventListener('mousedown', function(e) {
  // Prevent pointer events from firing for mouse clicks
  preventPointerEvents = true;
  setTimeout(function() {
    preventPointerEvents = false;
  }, 100);
}, { passive: true });

gameEl.addEventListener('click', function(e) {
  var t = closestEl(e.target, '.tile');
  if (!t) return;
  var r = parseInt(t.getAttribute('data-row'), 10);
  var c = parseInt(t.getAttribute('data-col'), 10);
  if (!isNaN(r) && !isNaN(c)) {
    if (interactionMode === 'drag') return;
    lastSelectVia='tap';
    selectTile(r, c);
  }
}, { passive: true });

function attachInputListeners(){
  // Re-enable pointer events for dragging only
  if (HAS_POINTER) {
    gameEl.addEventListener('pointerdown', function(e){ 
      pointerDown(e); 
      try { if (gameEl.setPointerCapture) gameEl.setPointerCapture(e.pointerId); } catch(_e){} 
    }, { passive: false });
    gameEl.addEventListener('pointermove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('pointerup', onGestureEnd, { passive: true });
  } else {
    gameEl.addEventListener('touchstart', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('touchmove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('touchend', onGestureEnd, { passive: true });
    gameEl.addEventListener('mousedown', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('mousemove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('mouseup', onGestureEnd, { passive: true });
  }
}

// --- Path drawing with SVG lines ---
function drawPath() {
  overlay.innerHTML = '';
  if (selectedTiles.length < 2) return;
  var points = [];
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; points.push(getTileCenter(t[0], t[1])); }
  var path = '';
  for (var i = 0; i < points.length - 1; i++) {
    path += '<line x1="' + points[i].x + '" y1="' + points[i].y + '" x2="' + points[i+1].x + '" y2="' + points[i+1].y + '" stroke="#007bff" stroke-width="5" stroke-linecap="round"/>';
  }
  overlay.innerHTML = path;
}

// --- Letter values loading ---
async function loadLetterValues() {
  try {
    var res = await fetch('en-lettervalues.txt');
    if (!res.ok) throw new Error('fetch failed');
    var text = await res.text();
    text.split(/\r?\n/).forEach(function(line){
      line = (line||'').trim(); if (!line) return;
      var parts = line.split('\t');
      if (parts.length >= 2) {
        var letter = parts[0].trim();
        var score = parseInt(parts[1], 10);
        if (letter && !isNaN(score)) {
          LETTER_SCORES[letter.toUpperCase()] = score;
        }
      }
    });
    dbg('LETTERS','loaded');
  } catch(e) { 
    dbg('LETTERS','fail'); 
    // Fallback to original values
    LETTER_SCORES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10};
  }
}

// --- Dictionary loading ---
async function loadDictionary() {
  try {
    var res = await fetch('en-words.txt');
    if (!res.ok) throw new Error('fetch failed');
    var text = await res.text();
    var words = text.split(/\r?\n/);
    dbg('DICT','processing ' + words.length + ' words');
    
    // Process words in chunks to avoid blocking the main thread
    var chunkSize = 1000;
    var wordIndex = 0;
    
    function processChunk() {
      var endIndex = Math.min(wordIndex + chunkSize, words.length);
      for (var i = wordIndex; i < endIndex; i++) {
        var w = (words[i] || '').trim();
        if (!w) continue;
        var up = w.toUpperCase();
        if (up.length > MAX_WORD_LEN) continue;
        DICT.add(up);
        for (var j = 1; j <= up.length; j++) PREFIX.add(up.slice(0, j));
      }
      wordIndex = endIndex;
      
      if (wordIndex < words.length) {
        // Show progress occasionally
        if (wordIndex % 50000 === 0) {
          var progress = Math.round((wordIndex / words.length) * 100);
          showStatus('<span class="dict-loading">Loading dictionary... ' + progress + '%</span>', 'info');
        }
        // Schedule next chunk processing
        setTimeout(processChunk, 0);
      } else {
        dictionaryReady = true;
        dbg('DICT','complete');
        clearStatus(); // Clear loading message
        // Re-render grid to update validation styles if needed
        if (selectedTiles.length > 0) {
          updateWordDisplay();
        }
      }
    }
    
    processChunk();
  } catch(e) { 
    dictionaryReady = false; 
    dbg('DICT','fail'); 
  }
}

// --- Playability check ---
function gridHasAnyWord() {
  var visited = Array(ROWS); for (var r=0;r<ROWS;r++){ visited[r]=Array(COLS); for (var c=0;c<COLS;c++) visited[r][c]=false; }
  var dirs = [-1, 0, 1];
  function dfs(r, c, prefix) {
    var next = prefix + grid[r][c].letter;
    var up = next.toUpperCase();
    if (dictionaryReady && !PREFIX.has(up)) return false;
    if (dictionaryReady && DICT.has(up)) return true;
    visited[r][c] = true;
    for (var i=0;i<dirs.length;i++) for (var j=0;j<dirs.length;j++){
      var dr = dirs[i], dc = dirs[j];
      if (dr === 0 && dc === 0) continue;
      var nr = r + dr, nc = c + dc;
      if (isInBounds(nr, nc) && !visited[nr][nc]) {
        if (dfs(nr, nc, next)) { visited[r][c] = false; return true; }
      }
    }
    visited[r][c] = false; return false;
  }
  for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) if (dfs(r, c, '')) return true;
  return !dictionaryReady; // if no dictionary, assume playable
}

function ensurePlayableOrReshuffle() {
  if (gridHasAnyWord()) { clearStatus(); saveState(); return; }
  paused = true; btnConfirm.disabled = true; btnReject.disabled = true;
  showStatus('<strong>No words found</strong>, reshuffling...', 'warn');
  var attempts = 0;
  var tryReshuffle = function () {
    attempts++;
    makeRandomGrid(); renderGrid();
    if (gridHasAnyWord() || attempts > 50) {
      paused = false; btnConfirm.disabled = false; btnReject.disabled = false; clearStatus(); saveState();
    } else {
      setTimeout(tryReshuffle, 0);
    }
  };
  tryReshuffle();
}

// ---- Controls ----
btnConfirm.addEventListener('click', function(){ dbg('BTN_CF'); confirmWord(true); });
btnConfirm.addEventListener('touchend', function(e){ dbg('BTN_CF_T'); if(e&&e.preventDefault) e.preventDefault(); confirmWord(true); }, {passive:false});
btnReject.addEventListener('click', function(){ dbg('BTN_CLR'); rejectWord(); });
btnNewGame.addEventListener('click', function(){
  // Only confirm if game is in progress (not finished)
  if (turns > 0 && (score > 0 || selectedTiles.length > 0)) {
    if (!confirm('Start a new game? Your current progress will be lost.')) {
      return;
    }
  }
  
  score = 0; turns = DEFAULT_TURNS; scoreDisplay.textContent = 'Score: ' + score; turnsDisplay.textContent = 'Turns Left: ' + turns;
  acceptedWords = []; updateWordsList();
  
  // Reset special effects for enhanced browsers
  if (ANIM) {
    gameEl.classList.remove('game-complete');
    // Remove any remaining confetti
    var confettis = document.querySelectorAll('.confetti');
    for (var i = 0; i < confettis.length; i++) {
      if (confettis[i].parentNode) confettis[i].parentNode.removeChild(confettis[i]);
    }
  }
  
  // Reset tile visibility and remove celebration effects
  var tiles = gameEl.getElementsByClassName('tile');
  for (var i = 0; i < tiles.length; i++) {
    tiles[i].style.visibility = 'visible';
    tiles[i].style.opacity = '1';
    tiles[i].classList.remove('celebration');
  }
  
  makeRandomGrid(); renderGrid(); clearSelection(); paused = false; clearStatus(); ensurePlayableOrReshuffle(); saveState();
});

// Theme toggle (non-Kindle)
if (btnTheme) {
  btnTheme.addEventListener('click', function(){
    var next = (settings.theme === 'auto') ? 'dark' : (settings.theme === 'dark') ? 'light' : 'auto';
    settings.theme = next;
    try {
      var raw = localStorage.getItem('lexfall_settings') || '{}';
      var s = {}; try { s = JSON.parse(raw) || {}; } catch(e){}
      s.theme = next;
      localStorage.setItem('lexfall_settings', JSON.stringify(s));
    } catch(e){}
    applyThemeFromSettings();
    updateThemeToggleGlyph();
  });
}

// ---- Boot ----
(async function init(){
  loadSettings();
  
  // Determine animation and contrast modes based on settings and device capability
  var useAnimations = ENHANCED_BROWSER && !settings.noAnim && !LOW_END_MODE;
  var useHighContrast = settings.highContrast || settings.noAnim || LOW_END_MODE;
  
  // Apply appropriate classes
  if (useAnimations) {
    document.body.classList.add('enhanced');
    dbg('BOOT','ANIM=1 EB='+ENHANCED_BROWSER+' LE='+LOW_END_MODE+' NA='+settings.noAnim+' HP='+HAS_POINTER);
  } else {
    document.body.classList.add('no-anim');
    dbg('BOOT','ANIM=0 EB='+ENHANCED_BROWSER+' LE='+LOW_END_MODE+' NA='+settings.noAnim+' HP='+HAS_POINTER);
  }
  
  if (useHighContrast) {
    document.body.classList.add('high-contrast');
    dbg('BOOT','HC=1');
  }
  // Apply theme classes and set toggle glyph
  applyThemeFromSettings();
  updateThemeToggleGlyph();
  // Hide theme toggle on Kindle/low-end
  try { if (LOW_END_MODE && btnTheme) btnTheme.style.display = 'none'; } catch(e){}
  
  if (DEBUG) {
    document.body.classList.add('debug-mode');
    dbg('BOOT','DEBUG=1');
  }
  
  // Set global ANIM variable for backward compatibility
  window.ANIM = useAnimations;
  
  // Load letter values first, then render grid with correct scores
  try { await loadLetterValues(); } catch(e) {}
  
  // Start dictionary loading in background (non-blocking)
  setTimeout(function() {
    showStatus('<span class="dict-loading">Loading dictionary...</span>', 'info');
    try { loadDictionary(); } catch(e) {}
  }, 0);
  
  var restored = loadState();
  if (!restored) makeRandomGrid();
  renderGrid();
  scoreDisplay.textContent = 'Score: ' + score;
  turnsDisplay.textContent = 'Turns Left: ' + turns;
  updateWordsList();
  if (turns <= 0) {
    paused = true;
    dbg('BOOT_T0');
    showStatus('<strong>Out of turns.</strong> Tap <em>New Game</em> to play again.', 'warn');
    btnConfirm.style.display = 'none';
  }
  attachInputListeners();
  sizeGridSquare();
  sizeTilesSquare();
  ensurePlayableOrReshuffle();
})();
</script>
</body>
</html>
