<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
  <title>Lexfall</title>
  <style>
  /* Legacy-friendly styles: no CSS variables, flex fallback by default */
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; text-align:center; margin:0; padding:12px; background:#f0f0f0; }
  h1 { margin:6px 0 4px; font-size:1.25rem; }

  #container { position:relative; width:100%; max-width:420px; margin:0 auto; }

  /* Fixed settings icon */
  #settingsIcon {
    position:fixed; top:8px; right:8px; width:36px; height:36px;
    display:inline-flex; align-items:center; justify-content:center;
    background:#ffffff; border:2px solid #cccccc; border-radius:50%;
    text-decoration:none; z-index:9999; box-shadow:0 1px 2px rgba(0,0,0,0.08);
  }
  #settingsIcon svg { width:18px; height:18px; fill:#333333; }

  /* HUD */
  #hud { max-width:420px; margin:8px auto 10px; }
  #wordDisplay { font-weight:700; margin-bottom:4px; }
  #scoreDisplay, #turnsLeft { display:inline-block; width:49%; font-size:0.95rem; }

  /* Game: flex fallback (default) */
  #game {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    width:100%;
    position:relative;
    background:#e0e0e0;
    border-radius:12px;
    padding:6px;
    min-height:320px; /* ensures visibility if JS sizing fails */
  }

  .tile {
    background:#ffffff;
    border:2px solid #cccccc;
    font-size:2.1em;
    font-weight:800;
    user-select:none;
    border-radius:12px;
    transition:background .15s;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    touch-action:none;
    width:calc(25% - 8px);
    margin:4px;
    /* height will be set equal to width via JS to make squares */
    overflow:hidden;
  }
  
  /* Enhanced animations for capable browsers */
  .enhanced .tile {
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1), background 0.15s;
  }
  .enhanced .tile:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .enhanced .tile.selected {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0,0,0,0.2);
  }
  
  /* Tile removal animations */
  .enhanced .tile.removing {
    animation: tileRemove 0.4s cubic-bezier(0.4, 0, 1, 1) forwards;
  }
  .enhanced .tile.dropping {
    animation: tileDrop 0.6s cubic-bezier(0.2, 0.8, 0.4, 1) forwards;
  }
  .enhanced .tile.spawning {
    animation: tileSpawn 0.5s cubic-bezier(0.2, 0.8, 0.4, 1) forwards;
  }
  
  @keyframes tileRemove {
    0% { transform: scale(1); opacity: 1; }
    50% { transform: scale(0.8) rotateZ(10deg); opacity: 0.5; }
    100% { transform: scale(0); opacity: 0; }
  }
  
  @keyframes tileDrop {
    from { transform: translateY(-100px) scale(0.9); opacity: 0.7; }
    to { transform: translateY(0) scale(1); opacity: 1; }
  }
  
  @keyframes tileSpawn {
    from { transform: scale(0) rotateZ(180deg); opacity: 0; }
    60% { transform: scale(1.1) rotateZ(0deg); opacity: 0.8; }
    to { transform: scale(1) rotateZ(0deg); opacity: 1; }
  }
  
  /* Game completion effects */
  .enhanced .celebration {
    animation: celebrate 2s ease-in-out infinite;
  }
  
  .enhanced .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    border-radius: 50%;
    animation: confettiFall 3s linear infinite;
  }
  
  .enhanced .confetti:nth-child(2n) { background: #4ecdc4; animation-delay: 0.5s; }
  .enhanced .confetti:nth-child(3n) { background: #45b7d1; animation-delay: 1s; }
  .enhanced .confetti:nth-child(4n) { background: #96ceb4; animation-delay: 1.5s; }
  .enhanced .confetti:nth-child(5n) { background: #ffd93d; animation-delay: 2s; }
  
  @keyframes celebrate {
    0%, 100% { transform: scale(1) rotateZ(0deg); }
    25% { transform: scale(1.1) rotateZ(5deg); }
    75% { transform: scale(1.1) rotateZ(-5deg); }
  }
  
  @keyframes confettiFall {
    0% {
      transform: translateY(-100vh) rotateZ(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) rotateZ(720deg);
      opacity: 0;
    }
  }
  
  /* Enhanced game completion background effect */
  .enhanced .game-complete {
    background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffd93d);
    background-size: 400% 400%;
    animation: gradientShift 3s ease infinite;
    border-radius: 20px;
  }
  
  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  .tile.selected { background:#e8f0ff; border-color:#cccccc; }
  .tile.selected.valid { background:#bff0cf; border-color:#3bb273; }
  .tile.selected.invalid { background:#ffecec; border-color:#dc3545; }
  .tile.empty { background:#f9f9f9; border:2px dashed #dddddd; }
  .tile .score { position:absolute; right:6px; bottom:4px; font-size:.5em; opacity:.8; }

  #overlay { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:5; }

  #controls { display:flex; justify-content:center; gap:10px; margin:10px auto; }
  button { padding:.9em 1.1em; margin:.2em; font-size:1em; border-radius:10px; border:none; cursor:pointer; }
  #confirm { background:#3bb273; color:#fff; display:none; }
  #reject { background:#dc3545; color:#fff; display:none; }

  /* New Game emphasis */
  #newGame {
    display:none; background:#ff8c00; color:#fff; font-weight:800;
    box-shadow:0 0 0 0 rgba(255,140,0,0.7);
    animation:pulseGlow 1.7s infinite;
  }
  @keyframes pulseGlow {
    0% { box-shadow:0 0 0 0 rgba(255,140,0,0.7); }
    70% { box-shadow:0 0 0 16px rgba(255,140,0,0); }
    100% { box-shadow:0 0 0 0 rgba(255,140,0,0); }
  }

  #status { max-width:420px; margin:8px auto 0; font-size:.98em; }

  /* If CSS Grid is supported, use it */
  @supports (display: grid) {
    #game {
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:6px;
      padding:6px;
    }
    .tile { width:auto; margin:0; }
  }

  /* Responsive tweaks */
  @media (max-width: 380px) {
    .tile { font-size:1.7em; }
    #settingsIcon { width:32px; height:32px; }
    #settingsIcon svg { width:16px; height:16px; }
  }
  @media (max-width: 330px) {
    .tile { font-size:1.55em; }
  }
</style>
</head>
<body>

<h1>Lexfall</h1>
<a id="settingsIcon" href="settings.html" aria-label="Settings" title="Settings">
  <svg viewBox="0 0 24 24" role="img" aria-hidden="true">
    <path d="M12 8.8a3.2 3.2 0 1 0 0 6.4 3.2 3.2 0 0 0 0-6.4zm9.4 3.2c0-.5 0-.9-.1-1.3l2-1.6-2-3.4-2.4 1a8.8 8.8 0 0 0-2.2-1.3l-.3-2.6H9.6l-.3 2.6a8.8 8.8 0 0 0-2.2 1.3l-2.4-1-2 3.4 2 1.6c0 .4-.1 .8-.1 1.3s0 .9 .1 1.3l-2 1.6 2 3.4 2.4-1c.7 .5 1.4 .9 2.2 1.3l.3 2.6h4.6l.3-2.6c.8-.4 1.5-.8 2.2-1.3l2.4 1 2-3.4-2-1.6c.1-.4 .1-.8 .1-1.3zM12 6.6a5.4 5.4 0 1 1 0 10.8A5.4 5.4 0 0 1 12 6.6z"/>
  </svg>
</a>
<div id="hud">
  <div id="wordDisplay">Word:</div>
  <div id="scoreDisplay">Score: 0</div>
  <div id="turnsLeft">Turns Left: 10</div>
</div>
<div id="container">
  <div id="game"></div>
  <svg id="overlay"></svg>
</div>
<div id="controls">
  <button id="confirm" type="button" onclick="confirmWord(true)">Confirm</button>
  <button id="reject">Clear</button>
  <button id="newGame">New Game</button>
</div>
<div id="status"></div>

<script>
// --- Minimal polyfills for weak browsers ---
if (!('Math' in window && typeof Math.hypot === 'function')) {
  Math.hypot = function(){ var s=0; for (var i=0;i<arguments.length;i++){ var n=Number(arguments[i])||0; s+=n*n; } return Math.sqrt(s); };
}
if (typeof window.Set === 'undefined') {
  (function(){
    function SimpleSet(){ this._o = Object.create(null); }
    SimpleSet.prototype.add = function(v){ this._o[v] = 1; return this; };
    SimpleSet.prototype.has = function(v){ return !!this._o[v]; };
    window.Set = SimpleSet;
  })();
}

// ---- Config ----
var ROWS = 4, COLS = 4;
var TILE_RADIUS_PX = 35;
var MAX_WORD_LEN = 16;
var DEFAULT_TURNS = 10;
var LETTER_SCORES = {A:1,B:3,C:3,D:2,E:1,F:4,G:2,H:4,I:1,J:8,K:5,L:1,M:3,N:1,O:1,P:3,Q:10,R:1,S:1,T:1,U:1,V:4,W:4,X:8,Y:4,Z:10};

// ---- DOM ----
var gameEl = document.getElementById('game');
var overlay = document.getElementById('overlay');
var wordDisplay = document.getElementById('wordDisplay');
var scoreDisplay = document.getElementById('scoreDisplay');
var turnsDisplay = document.getElementById('turnsLeft');
var statusEl = document.getElementById('status');
var btnConfirm = document.getElementById('confirm');
var btnReject = document.getElementById('reject');
var btnNewGame = document.getElementById('newGame');

// Browser capability detection
var HAS_POINTER = !!window.PointerEvent;
var ENHANCED_BROWSER = (function() {
  try {
    // Check for modern CSS features and reasonable performance
    return !!(window.CSS && CSS.supports && 
             CSS.supports('transform', 'scale(1)') &&
             CSS.supports('transition', 'all 0.3s') &&
             CSS.supports('animation', 'none') &&
             window.requestAnimationFrame &&
             !navigator.userAgent.toLowerCase().includes('kindle'));
  } catch(e) { return false; }
})();

// ---- Game State ----
var grid = [], selectedTiles = [], score = 0, turns = DEFAULT_TURNS;
var pointerActive = false, paused = false, slidThisGesture = false;
var DICT = new Set();
var PREFIX = new Set();
var dictionaryReady = false;
var settings = { minLen: 3, autoConfirm: true };

// ---- Utils ----
function showStatus(html, type){ statusEl.innerHTML = '<div class="' + (type||'info') + '">' + html + '</div>'; }
function clearStatus(){ statusEl.innerHTML = ''; }

function saveState() {
  try {
    var letters = grid.map(function(row){ return row.map(function(cell){ return cell.letter; }); });
    var state = { letters: letters, score: score, turns: turns };
    localStorage.setItem('lexfall_state', JSON.stringify(state));
  } catch (e) {}
}

function loadState() {
  try {
    var raw = localStorage.getItem('lexfall_state');
    if (!raw) return false;
    var s = JSON.parse(raw);
    if (!s || !Array.isArray(s.letters) || typeof s.score !== 'number' || typeof s.turns !== 'number') return false;
    grid = [];
    for (var r=0; r<ROWS; r++){
      var row = [];
      for (var c=0; c<COLS; c++){
        var letter = (s.letters[r] && s.letters[r][c]) || null;
        // Sanitize: require A-Z single char, else random
        if (typeof letter !== 'string' || !/^[A-Z]$/.test(letter)) letter = randomLetter();
        row.push({ letter: letter, element: null });
      }
      grid.push(row);
    }
    score = s.score; turns = s.turns;
    return true;
  } catch (e) { return false; }
}

function loadSettings(){
  try {
    var s = JSON.parse(localStorage.getItem('lexfall_settings')||'{}');
    if (s && typeof s.minLen==='number') settings.minLen = Math.max(2, Math.min(16, s.minLen));
    if (typeof s.autoConfirm==='boolean') settings.autoConfirm = s.autoConfirm;
  } catch(e){}
}

// Maintain square grid for browsers without aspect-ratio
function sizeGridSquare(){
  try {
    var supportsAspect = (window.CSS && CSS.supports && CSS.supports('aspect-ratio', '1/1'));
    if (!supportsAspect) {
      var w = gameEl.clientWidth || 320;
      gameEl.style.height = w + 'px';
    }
  } catch(e){}
  // Also size overlay to match
  var rect = gameEl.getBoundingClientRect();
  overlay.setAttribute('width', rect.width);
  overlay.setAttribute('height', rect.height);
  overlay.style.width = rect.width + 'px';
  overlay.style.height = rect.height + 'px';
}
window.addEventListener('resize', sizeGridSquare);

// Make tiles square for legacy browsers (no CSS aspect-ratio or grid)
function sizeTilesSquare(){
  try {
    var tiles = gameEl.getElementsByClassName('tile');
    if (!tiles || !tiles.length) return;
    for (var i=0;i<tiles.length;i++){
      var w = tiles[i].offsetWidth || 0;
      if (w > 0) { tiles[i].style.height = w + 'px'; }
    }
    // Sync overlay box to #game
    var rect = gameEl.getBoundingClientRect();
    overlay.setAttribute('width', rect.width);
    overlay.setAttribute('height', rect.height);
    overlay.style.width = rect.width + 'px';
    overlay.style.height = rect.height + 'px';
  } catch(e){}
}
window.addEventListener('resize', sizeTilesSquare);


// Letter randomizer
function randomLetter() {
  var letters = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";
  return letters[Math.floor(Math.random() * letters.length)];
}

// Build empty grid and tiles
function makeRandomGrid() {
  grid = [];
  for (var r = 0; r < ROWS; r++) {
    var row = [];
    for (var c = 0; c < COLS; c++) row.push({ letter: randomLetter(), element: null });
    grid.push(row);
  }
}

function renderGrid() {
  gameEl.innerHTML = '';
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
    }
  }
  setTimeout(sizeGridSquare, 0);
  setTimeout(sizeTilesSquare, 0);
  updateWordDisplay();
  drawPath();
}

function renderGridWithAnimations(newTiles, droppingTiles) {
  gameEl.innerHTML = '';
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      var tile = document.createElement('div');
      tile.className = 'tile';
      if (!grid[r][c].letter) tile.className += ' empty';
      tile.setAttribute('data-row', r);
      tile.setAttribute('data-col', c);
      var ch = grid[r][c].letter || '';
      var val = LETTER_SCORES[ch] || 0;
      tile.innerHTML = '<span class="letter">' + ch + '</span><span class="score">' + val + '</span>';
      gameEl.appendChild(tile);
      grid[r][c].element = tile;
      
      // Add appropriate animations for enhanced browsers
      if (ENHANCED_BROWSER && ch) {
        var isNewTile = newTiles && newTiles.some(function(nt) { return nt[0] === r && nt[1] === c; });
        var isDroppingTile = droppingTiles && droppingTiles.some(function(dt) { return dt[0] === r && dt[1] === c; });
        
        if (isNewTile) {
          tile.classList.add('spawning');
          (function(t){ setTimeout(function(){ t.classList.remove('spawning'); }, 500); })(tile);
        } else if (isDroppingTile) {
          tile.classList.add('dropping');
          (function(t){ setTimeout(function(){ t.classList.remove('dropping'); }, 600); })(tile);
        }
      }
    }
  }
  setTimeout(sizeGridSquare, 0);
  setTimeout(sizeTilesSquare, 0);
  updateWordDisplay();
  drawPath();
}

function isInBounds(r, c) { return r >= 0 && r < ROWS && c >= 0 && c < COLS; }
function alreadySelected(r, c) { for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; if (t[0]===r && t[1]===c) return true; } return false; }
function isAdjacentForgiving(r, c, pr, pc) { return Math.abs(r - pr) <= 1 && Math.abs(c - pc) <= 1; }

function selectTile(r, c) {
  if (!isInBounds(r, c) || paused) return;
  if (alreadySelected(r, c)) return;
  if (!grid[r][c].letter) return;
  if (selectedTiles.length > 0) {
    var last = selectedTiles[selectedTiles.length - 1];
    if (!isAdjacentForgiving(r, c, last[0], last[1])) return;
  }
  selectedTiles.push([r, c]);
  if (selectedTiles.length >= 2) { slidThisGesture = true; }
  grid[r][c].element.className += ' selected';
  updateWordDisplay();
  drawPath();
}

function currentWord() {
  var out = '';
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; out += grid[t[0]][t[1]].letter; }
  return out;
}

function refreshSelectionStyles() {
  var up = currentWord().toUpperCase();
  var meetsLen = up.length >= settings.minLen;
  var isValid = up.length > 0 && meetsLen && (dictionaryReady ? DICT.has(up) : true);
  var isDead = dictionaryReady && up.length > 0 && !PREFIX.has(up);
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bvalid\b|\binvalid\b/g, '').trim();
    if (isValid) el.className += ' valid';
    else if (isDead) el.className += ' invalid';
  }
  btnConfirm.style.display = (dictionaryReady ? (isValid ? 'inline-block' : 'none') : (meetsLen ? 'inline-block' : 'none'));
  btnConfirm.disabled = false;
  btnReject.style.display = selectedTiles.length ? 'inline-block' : 'none';
}

function updateWordDisplay() {
  var word = currentWord();
  refreshSelectionStyles();
  if (!word.length) wordDisplay.textContent = 'Word:';
  else {
    var pts = calculateScore(word.toUpperCase());
    wordDisplay.textContent = 'Word: ' + word + ' (' + pts + ')';
  }
}

function calculateScore(word) {
  var acc = 0;
  for (var i=0;i<word.length;i++){ var ch = word.charAt(i); acc += LETTER_SCORES[ch] || 0; }
  return acc;
}

function confirmWord(force) {
  if (selectedTiles.length === 0 || turns === 0) return;
  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= settings.minLen;
  if (!force && !((dictionaryReady ? DICT.has(word) : true) && meetsLen)) { rejectWord(); return; }
  var wordScore = calculateScore(word);
  score += wordScore; scoreDisplay.textContent = 'Score: ' + score;
  turns--; turnsDisplay.textContent = 'Turns Left: ' + turns;
  removeAndDropTiles();
  saveState();
  maybeFinishGame();
}

function showWellDone() {
  for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) grid[r][c].letter = '';
  var row1 = ['W','E','L','L'];
  var row2 = ['D','O','N','E'];
  for (var c = 0; c < COLS; c++) { grid[1][c].letter = row1[c]; }
  for (var c = 0; c < COLS; c++) { grid[2][c].letter = row2[c]; }
  renderGrid();
  
  if (ENHANCED_BROWSER) {
    // Add celebration effects
    gameEl.classList.add('game-complete');
    
    // Add celebration class to WELL DONE tiles
    setTimeout(function() {
      for (var r = 1; r <= 2; r++) {
        for (var c = 0; c < COLS; c++) {
          if (grid[r][c].element) {
            grid[r][c].element.classList.add('celebration');
          }
        }
      }
    }, 100);
    
    // Create confetti effect
    createConfetti();
  }
}

function createConfetti() {
  if (!ENHANCED_BROWSER) return;
  
  var container = document.getElementById('container');
  var confettiCount = 50;
  
  for (var i = 0; i < confettiCount; i++) {
    var confetti = document.createElement('div');
    confetti.className = 'confetti';
    confetti.style.left = Math.random() * 100 + '%';
    confetti.style.animationDelay = Math.random() * 3 + 's';
    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
    container.appendChild(confetti);
    
    // Remove confetti after animation
    setTimeout(function(c) {
      if (c.parentNode) c.parentNode.removeChild(c);
    }, 5000, confetti);
  }
}

function maybeFinishGame() {
  if (turns <= 0) {
    paused = true;
    showStatus('<strong>Congratulations!</strong> Final score: <strong>' + score + '</strong>.', 'success');
    showWellDone();
    btnNewGame.style.display = 'inline-block';
  }
}

function rejectWord() { clearSelection(); }

function clearSelection() {
  for (var i=0;i<selectedTiles.length;i++){
    var rc = selectedTiles[i], el = grid[rc[0]][rc[1]].element;
    el.className = el.className.replace(/\bselected\b|\bvalid\b|\binvalid\b/g,'').trim();
  }
  selectedTiles = [];
  updateWordDisplay();
  drawPath();
}

// Remove selected tiles, drop down, refill from top
function removeAndDropTiles() {
  if (ENHANCED_BROWSER) {
    // Animate removal first
    for (var i = 0; i < selectedTiles.length; i++) {
      var rc = selectedTiles[i];
      var tile = grid[rc[0]][rc[1]].element;
      tile.classList.add('removing');
    }
    
    // Wait for removal animation, then drop and refill
    setTimeout(function() {
      performTileDropAndRefill();
    }, 400);
  } else {
    // Immediate update for e-ink browsers
    performTileDropAndRefill();
  }
}

function performTileDropAndRefill() {
  // Store which tiles were selected before removing them
  var affectedColumns = {};
  for (var i = 0; i < selectedTiles.length; i++) {
    affectedColumns[selectedTiles[i][1]] = true;
  }
  
  // Remove selected tiles
  for (var i=0;i<selectedTiles.length;i++){ var rc = selectedTiles[i]; grid[rc[0]][rc[1]].letter = null; }
  
  // Clear selection now that tiles are removed
  clearSelection();
  
  // Drop down per column and track new positions
  var newTiles = [];
  var droppingTiles = [];
  
  for (var c = 0; c < COLS; c++) {
    if (!affectedColumns[c]) continue; // Skip columns that weren't affected
    
    // Collect existing letters from bottom to top
    var letters = [];
    for (var r = ROWS - 1; r >= 0; r--) {
      if (grid[r][c].letter) letters.push(grid[r][c].letter);
    }
    
    // Clear the column
    for (var r = 0; r < ROWS; r++) {
      grid[r][c].letter = null;
    }
    
    // Place existing letters at bottom
    for (var i = 0; i < letters.length; i++) {
      grid[ROWS - 1 - i][c].letter = letters[i];
      if (ENHANCED_BROWSER) {
        droppingTiles.push([ROWS - 1 - i, c]);
      }
    }
    
    // Fill empty spaces at top with new letters
    for (var r = 0; r < ROWS - letters.length; r++) {
      grid[r][c].letter = randomLetter();
      if (ENHANCED_BROWSER) {
        newTiles.push([r, c]);
      }
    }
  }
  
  if (ENHANCED_BROWSER) {
    renderGridWithAnimations(newTiles, droppingTiles);
  } else {
    renderGrid();
  }
  
  ensurePlayableOrReshuffle();
}

// --- Hit testing helpers ---
function getTileCenter(r, c) {
  var gridRect = gameEl.getBoundingClientRect();
  var tile = grid[r][c].element; var tileRect = tile.getBoundingClientRect();
  return { x: tileRect.left + tileRect.width / 2 - gridRect.left, y: tileRect.top + tileRect.height / 2 - gridRect.top };
}

function tileFromPointerEvent(e) {
  var gridRect = gameEl.getBoundingClientRect();
  var clientX = (e.touches && e.touches[0] ? e.touches[0].clientX : e.clientX);
  var clientY = (e.touches && e.touches[0] ? e.touches[0].clientY : e.clientY);
  var x = clientX - gridRect.left;
  var y = clientY - gridRect.top;
  for (var r = 0; r < ROWS; r++) {
    for (var c = 0; c < COLS; c++) {
      if (!grid[r][c].letter) continue;
      var center = getTileCenter(r, c); var dx = x - center.x; var dy = y - center.y;
      if (Math.hypot(dx, dy) < TILE_RADIUS_PX) return [r, c];
    }
  }
  return null;
}

// --- Pointer interactions ---
function pointerDown(e) {
  if (paused) return;
  if (e && e.preventDefault) e.preventDefault();
  pointerActive = true; slidThisGesture = false;
  var tile = tileFromPointerEvent(e);
  if (tile) selectTile(tile[0], tile[1]);
}

function pointerMove(e) {
  if (!pointerActive || paused) return;
  if (e && e.preventDefault) e.preventDefault();
  var tile = tileFromPointerEvent(e); if (!tile) return;
  var r = tile[0], c = tile[1];
  
  // Check if this tile is already selected
  var selectedIndex = -1;
  for (var i = 0; i < selectedTiles.length; i++) {
    if (selectedTiles[i][0] === r && selectedTiles[i][1] === c) {
      selectedIndex = i;
      break;
    }
  }
  
  if (selectedIndex !== -1) {
    // Tile is already selected - allow retracing by unselecting tiles after this one
    if (selectedIndex < selectedTiles.length - 1) {
      // Remove all tiles after this one (retrace back to this tile)
      for (var i = selectedIndex + 1; i < selectedTiles.length; i++) {
        var rc = selectedTiles[i];
        var el = grid[rc[0]][rc[1]].element;
        el.className = el.className.replace(/\bselected\b|\bvalid\b|\binvalid\b/g, '').trim();
      }
      selectedTiles = selectedTiles.slice(0, selectedIndex + 1);
      updateWordDisplay();
      drawPath();
    }
  } else {
    // Tile is not selected - try to select it
    if (selectedTiles.length === 0) selectTile(r, c);
    else {
      var last = selectedTiles[selectedTiles.length - 1];
      if (isAdjacentForgiving(r, c, last[0], last[1])) { selectTile(r, c); slidThisGesture = true; }
    }
  }
}

function onGestureEnd(){
  if (!pointerActive) return; 
  pointerActive = false;
  var wasSlide = !!slidThisGesture;
  slidThisGesture = false;
  if (!wasSlide) return; // taps: do nothing (no auto-confirm or auto-cancel)

  var word = currentWord().toUpperCase();
  var meetsLen = word.length >= settings.minLen;
  if (!settings.autoConfirm) return;

  var ok = dictionaryReady ? DICT.has(word) : true;
  if (meetsLen && ok) { 
    confirmWord(true);
  } else if (dictionaryReady) { 
    // Only auto-cancel when we know it's invalid via dictionary, and only for slides
    rejectWord();
  }
}

// Attach listeners
// Simple closest polyfill
function closestEl(el, selector){
  while (el && el.nodeType === 1){
    if ((el.matches && el.matches(selector)) || (el.msMatchesSelector && el.msMatchesSelector(selector))) return el;
    el = el.parentNode;
  }
  return null;
}
// Click-to-select fallback (helps Safari/old browsers where pointer events can be finicky)
gameEl.addEventListener('click', function(e){
  var t = closestEl(e.target, '.tile');
  if (!t) return;
  var r = parseInt(t.getAttribute('data-row'), 10);
  var c = parseInt(t.getAttribute('data-col'), 10);
  if (!isNaN(r) && !isNaN(c)) { selectTile(r, c); }
}, { passive: true });

function attachInputListeners(){
  if (HAS_POINTER) {
    gameEl.addEventListener('pointerdown', function(e){ pointerDown(e); try { if (gameEl.setPointerCapture) gameEl.setPointerCapture(e.pointerId); } catch(_e){} }, { passive: false });
    gameEl.addEventListener('pointermove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('pointerup', onGestureEnd, { passive: true });
  } else {
    gameEl.addEventListener('touchstart', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('touchmove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('touchend', onGestureEnd, { passive: true });
    gameEl.addEventListener('mousedown', function(e){ pointerDown(e); }, { passive: false });
    gameEl.addEventListener('mousemove', function(e){ pointerMove(e); }, { passive: false });
    document.addEventListener('mouseup', onGestureEnd, { passive: true });
  }
}

// --- Path drawing with SVG lines ---
function drawPath() {
  overlay.innerHTML = '';
  if (selectedTiles.length < 2) return;
  var points = [];
  for (var i=0;i<selectedTiles.length;i++){ var t=selectedTiles[i]; points.push(getTileCenter(t[0], t[1])); }
  var path = '';
  for (var i = 0; i < points.length - 1; i++) {
    path += '<line x1="' + points[i].x + '" y1="' + points[i].y + '" x2="' + points[i+1].x + '" y2="' + points[i+1].y + '" stroke="#007bff" stroke-width="5" stroke-linecap="round"/>';
  }
  overlay.innerHTML = path;
}

// --- Dictionary loading ---
async function loadDictionary() {
  try {
    var res = await fetch('en-words.txt');
    if (!res.ok) throw new Error('fetch failed');
    var text = await res.text();
    text.split(/\r?\n/).forEach(function(w){
      w = (w||'').trim(); if (!w) return; var up = w.toUpperCase(); if (up.length > MAX_WORD_LEN) return;
      DICT.add(up);
      for (var i = 1; i <= up.length; i++) PREFIX.add(up.slice(0, i));
    });
    dictionaryReady = true;
  } catch(e) { dictionaryReady = false; }
}

// --- Playability check ---
function gridHasAnyWord() {
  var visited = Array(ROWS); for (var r=0;r<ROWS;r++){ visited[r]=Array(COLS); for (var c=0;c<COLS;c++) visited[r][c]=false; }
  var dirs = [-1, 0, 1];
  function dfs(r, c, prefix) {
    var next = prefix + grid[r][c].letter;
    var up = next.toUpperCase();
    if (dictionaryReady && !PREFIX.has(up)) return false;
    if (dictionaryReady && DICT.has(up)) return true;
    visited[r][c] = true;
    for (var i=0;i<dirs.length;i++) for (var j=0;j<dirs.length;j++){
      var dr = dirs[i], dc = dirs[j];
      if (dr === 0 && dc === 0) continue;
      var nr = r + dr, nc = c + dc;
      if (isInBounds(nr, nc) && !visited[nr][nc]) {
        if (dfs(nr, nc, next)) { visited[r][c] = false; return true; }
      }
    }
    visited[r][c] = false; return false;
  }
  for (var r = 0; r < ROWS; r++) for (var c = 0; c < COLS; c++) if (dfs(r, c, '')) return true;
  return !dictionaryReady; // if no dictionary, assume playable
}

function ensurePlayableOrReshuffle() {
  if (gridHasAnyWord()) { clearStatus(); saveState(); return; }
  paused = true; btnConfirm.disabled = true; btnReject.disabled = true;
  showStatus('<strong>No words found</strong>, reshuffling...', 'warn');
  var attempts = 0;
  var tryReshuffle = function () {
    attempts++;
    makeRandomGrid(); renderGrid();
    if (gridHasAnyWord() || attempts > 50) {
      paused = false; btnConfirm.disabled = false; btnReject.disabled = false; clearStatus(); saveState();
    } else {
      setTimeout(tryReshuffle, 0);
    }
  };
  tryReshuffle();
}

// ---- Controls ----
btnConfirm.addEventListener('click', function(){ confirmWord(true); });
btnReject.addEventListener('click', rejectWord);
btnNewGame.addEventListener('click', function(){
  score = 0; turns = DEFAULT_TURNS; scoreDisplay.textContent = 'Score: ' + score; turnsDisplay.textContent = 'Turns Left: ' + turns;
  
  // Reset special effects for enhanced browsers
  if (ENHANCED_BROWSER) {
    gameEl.classList.remove('game-complete');
    // Remove any remaining confetti
    var confettis = document.querySelectorAll('.confetti');
    for (var i = 0; i < confettis.length; i++) {
      if (confettis[i].parentNode) confettis[i].parentNode.removeChild(confettis[i]);
    }
  }
  
  makeRandomGrid(); renderGrid(); clearSelection(); paused = false; btnNewGame.style.display = 'none'; clearStatus(); ensurePlayableOrReshuffle(); saveState();
});

// ---- Boot ----
(function init(){
  loadSettings();
  
  // Apply enhanced class for capable browsers
  if (ENHANCED_BROWSER) {
    document.body.classList.add('enhanced');
  }
  
  // Load dict but do not block the UI; tiles should render even if it fails
  try { loadDictionary(); } catch(e) {}
  var restored = loadState();
  if (!restored) makeRandomGrid();
  renderGrid();
  scoreDisplay.textContent = 'Score: ' + score;
  turnsDisplay.textContent = 'Turns Left: ' + turns;
  attachInputListeners();
  sizeGridSquare();
  sizeTilesSquare();
  ensurePlayableOrReshuffle();
})();
</script>
</body>
</html>
